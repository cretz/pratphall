<!DOCTYPE html>
<html>
  <head lang="en">
    <title>Pratphall</title>
    <link href="bootstrap.min.css" rel="stylesheet" />
    <style type=text/css>
      pre {
          width: 900px;
      }
    </style>
    <link href="pratphall.css" rel="stylesheet" />
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
  </head>
  <body>
    <div class="topbar">
      <h1 class="topbar-title">
        <a class="title" href="#Top">Pratphall</a>
        <small> - A typed language targeting <a href="http://php.net">PHP</a>*</small>
      </h1>
      <div style="text-align: right; position: relative; float: right; margin-top: 0px; right: 10px;">
        <p class="muted">*Actually, it's just <a href="http://typescriptlang.org">TypeScript</a> cross-compiled.</p>
        <a class="btn btn-link dropdown-toggle" data-toggle="dropdown" href="#" style="padding: 0px">
          Doc <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li class="dropdown-title">Getting Started</li>
          <li><a tabindex="-1" href="#GettingStarted-Installation">Installation</a></li>
          <li><a tabindex="-1" href="#GettingStarted-Compiling">Compiling</a></li>
          <li class="dropdown-title">Manual</li>
          <li><a tabindex="-1" href="#Manual-Introduction">Introduction</a></li>
          <li><a tabindex="-1" href="#Manual-Usage">Usage</a></li>
          <li><a tabindex="-1" href="#Manual-Types">Types</a></li>
          <li><a tabindex="-1" href="#Manual-Syntax">Syntax</a></li>
          <li><a tabindex="-1" href="#Manual-Structure">Structure</a></li>
          <li><a tabindex="-1" href="#Manual-Metaprogramming">Metaprogramming</a></li>
          <li><a tabindex="-1" href="#Manual-Faq">FAQ</a></li>
          <li><a tabindex="-1" href="#Manual-Appendices">Appendices</a></li>
        </ul> |
        <a href="try">Try</a> |
        <a href="https://github.com/cretz/pratphall">GitHub</a> |
        <a href="https://groups.google.com/d/forum/pratphall">Mailing List</a>
      </div>
    </div>
    <div class="container">
      <span class="bookmark" id="Top"></span>
      <div style="margin-top: 80px">
        <div style="float: left; width: 100px">&nbsp;</div>
        <div style="float: left; width: 300px">
          <h3>Features</h3>
          <ul>
            <li>Optional typing</li>
            <li>Readable PHP output</li>
            <li>IDE support</li>
            <li>Metaprogramming facilities</li>
            <li>PHP interoperability</li>
            <li>MIT licensed</li>
          </ul>
        </div>
        <div style="float: left; width: 400px">
          <h3>Anti-Features</h3>
          <ul>
            <li>Not fixing PHP standard library</li>
            <li>Not emitting obtuse/complicated PHP code</li>
            <li>Not auto-generating Pratphall from PHP code</li>
            <li>Not adding any code in TypeScript core</li>
            <li>Not supporting every PHP feature</li>
            <li>Not supporting every JS/TypeScript feature</li>
          </ul>
        </div>
        <br class="clearfix" style="clear: left;" />
      </div>
      <h1 style="color: red">Placeholder page...not ready yet!!!</h1>
      <h3>Overview</h3>
      <p>
        Pratphall is an optionally-typed language that compiles to readable PHP. PHP has a powerful engine and is very scalable since state is primarily per-request for PHP scripts. Unfortunately, due to the dynamic nature of PHP, it can be difficult to build large projects and retain the ability to refactor and manage the code. It can also be difficult to foresee errors with typing and unavailable variables. Almost all of these issues cause many problems that don't surface until runtime. Pratphall aims to solve this.
      </p>
      <p>
        Pratphall started as kind of a joke (hence the name) and proof of concept to see if <a href="http://typescriptlang.org">TypeScript</a> could be reliably translated. It turns out it can. So Pratphall is for all practical purposes just TypeScript (which is a typed superset of JavaScript) cross-compiled. And although not every single JS idiom directly translates, remembering that <strong>Pratphall is just TypeScript which is just typed JavaScript</strong> will help development greatly.
      </p>
      <h3>Example</h3>
      Here is an example of Pratphall compiling to PHP
      <div class="code">
        <pre><code data-language="javascript">//normal array
var arr = [1, 2, 3, 4, 5];

//loop and print
arr.forEach((value: number) => {
    echo('My value: ' + value + '\n');
});

//compile-time-only class
interface SampleContract extends Pct.CompileTimeOnly {
    requiredProperty: string;
    optionalProperty?: bool;
}

//function using compile-time class
function printInfo(info: SampleContract) {
    echo('Required: ' + info.requiredProperty + '\n');
    if (typeof info.optionalProperty !== 'undefined') {
        echo('Optional: ' + info.optionalProperty + '\n');
    }
}

//type inferred matching
printInfo({ requiredProperty: 'required val' });</code></pre>
        <pre><code data-language="php">//normal array
$arr = [1, 2, 3, 4, 5];

//loop and print
foreach ($arr as $value) {
    echo('My value: ' . $value . "\n");
}



/*Spacing added in example for clarity*/



//function using compile-time class
function printInfo($info) {
    echo('Required: ' . $info->requiredProperty . "\n");
    if (array_key_exists('optionalProperty', $info)) {
        echo('Optional: ' . $info->optionalProperty . "\n");
    }
}

//type-inferred matching
printInfo((object)[ 'requiredProperty' => 'required val' ]);</code></pre>
      </div>

      <span class="bookmark" id="GettingStarted"></span>
      <h2 class="para-link">Getting Started <a href="#GettingStarted">&nbsp;&para;</a></h2>

      <span class="bookmark" id="GettingStarted-Installation"></span>
      <h4 class="para-link">Installation <a href="#GettingStarted-Installation">&nbsp;&para;</a></h4>
      <p>To use Pratphall from the command line, simply install via NPM:</p>
      <pre>npm install -g pratphall</pre>
      <p>
        You may also want to install <a href="http://www.microsoft.com/en-us/download/details.aspx?id=34790">TypeScript for Visual Studio 2012</a> if you want to use Visual Studio as your editor. For more information about Visual Studio support, see <a href="#Manual-Appendices-VisualStudio">below</a>.
      </p>
      <p>If you want to build Pratphall from source, see the <a href="#Manual-Appendices-Building">Building From Source</a> appendix.</p>

      <span class="bookmark" id="GettingStarted-Compiling"></span>
      <h4 class="para-link">Compiling <a href="#GettingStarted-Compiling">&nbsp;&para;</a></h4>
      <p>Write the following simple script and save it as sayHello.ts:</p>
      <pre><code data-language="javascript">function sayHello(subject: string) {
    return 'Hello, ' + subject;
}

var theSubject = 'World';

echo(sayHello(theSubject) + '\n');</code></pre>
      <p>Now, to compile to PHP, run ppc like so:</p>
      <pre>ppc sayHello.ts</pre>
      <p>This will create a sayHello.php file that looks like this:</p>
      <pre><code data-language="php">function sayHello($subject) {
    return 'Hello, ' . $subject;
}

$theSubject = 'World';

echo(sayHello(theSubject) . "\n");</code></pre>
      <p>Running this with PHP will output what you expect. However, if you tried to compile this:</p>
      <pre><code data-language="javascript">function sayHello(subject: string) {
    return 'Hello, ' + subject;
}

var theSubject = 123;

echo(sayHello(theSubject) + '\n');</code></pre>
      <p>
        You would get: <code>sayHello.ts(7,5): Supplied parameters do not match any signature of call target</code>. This is because you are attempting to pass a number to a function that only accepts strings.
      </p>

      <span class="bookmark" id="Manual"></span>
      <h2 class="para-link">Manual <a href="#Manual">&nbsp;&para;</a></h2>

      <span class="bookmark" id="Manual-Introduction"></span>
      <h3 class="para-link">Introduction <a href="#Manual-Introduction">&nbsp;&para;</a></h3>

      <h4>Who?</h4>
      <p>
        Nobody really. It's a project that was started in <a href="http://github.com/cretz">my</a> spare time and only maintained in my <em>spare</em> time. There is no commercial support, no guarantee that anything will get fixed, and no guarantee that the project will be properly maintained. The only project known to  use Pratphall is <a href="http://github.com/cretz/dust-php">dust-php</a>. If Pratphall becomes popular, it is possible it could become a more professional language. Feel free to discuss the language or ask questions on the <a href="https://groups.google.com/d/forum/pratphall">mailing list</a>.
      </p>

      <h4>What?</h4>
      <p>
        Pratphall is <a href="http://typescriptlang.org">TypeScript</a> compiled to PHP. It includes several helpers to make this easier. Pratphall's code is licensed under the MIT license, but the Microsoft TypeScript code within (referenced as a submodule) is licensed under the Apache 2 license.
      </p>

      <h4>Where?</h4>
      <p>
        The source is on <a href="https://github.com/cretz/pratphall">GitHub</a> and the site is on <a href="https://github.com/cretz/pratphall/tree/gh-pages">GitHub</a>. Follow development, fork, send pull requests, and submit issues there.
      </p>

      <h4>When?</h4>
      <p>
        I don't know. It's in an almost alpha state until it gets more traction.
      </p>

      <h4>Why?</h4>
      <p>
        This is basically for static typing enthusiasts that use PHP either because they are forced to or like the PHP engine and scalability. Using PHPDoc annotations is rarely a good enough solution and editor support for them is limited. After noticing extreme parity between TypeScript and PHP, a simple tool was built to do the cross-compiling. This is the result.
      </p>
      <p>
        Pratphall can be used to make a really scalable codebase in PHP. It can also reduce verbosity (e.g. several classes/modules in one file) and increase productivity through editor support (e.g. Visual Studio with IntelliSense). Refactoring and determining use throughout the your codebase will now be really easy. And, if the abstraction is written properly, code can even be shared between JS/PHP. At the very least this really helps when defining typed model classes.
      </p>

      <h4>How?</h4>
      <p>
        Pratphall simply leverages the TypeScript compiler and type checker. Because TypeScript is written so well, it is very easy to change the language it emits to. In this case, a new emitter was written to just write PHP instead of JavaScript.
      </p>

      <span class="bookmark" id="Manual-Usage"></span>
      <h3 class="para-link">Usage <a href="#Manual-Usage">&nbsp;&para;</a></h3>
      <pre>ppc [options] FILE...</pre>
      <p>Options:</p>
      <dl class="heading-list">
        <dt><code>-c</code>, <code>--config FILE</code></dt>
        <dd>
          Use a JSON file for configuration options. Note values in the config file override command line options before this option and are overridden by command line options after this option. Read about <a href="#Manual-Appendices-Configuration">Configuration files</a> below.
        </dd>
        <dt><code>--exclude-outside</code></dt>
        <dd>Do not emit Pratphall files referenced in directories above and outside the given file. This is helpful for when you may only want to emit code from a test directory, not all the other code it references.</dd>
        <dt><code>--ext FILE</code></dt>
        <dd>Can be used as many times as necessary to include extensions</dd>
        <dt><code>--force-block</code></dt>
        <dd>Forces if, else, while, etc to have blocks on output even if single statements are given on input</dd>
        <dt><code>--function-brace-newline</code></dt>
        <dd>Put the opening brace of functions (but not closures) on the next line</dd>
        <dt><code>-h</code>, <code>--help</code></dt>
        <dd>Display help</dd>
        <dt><code>--indent-spaces COUNT</code></dt>
        <dd>Indent using the number of given spaces. The default is 4 spaces.</dd>
        <dt><code>--indent-tabs</code></dt>
        <dd>Indent using a single tab. The default is 4 spaces.</dd>
        <dt><code>--lint</code></dt>
        <dd>Do not output files, just parse/compile</dd>
        <dt><code>--no-comments</code></dt>
        <dd>Do not emit comments</dd>
        <dt><code>--no-js-lib</code></dt>
        <dd>Do not automatically include the lib.d.ts JS definitions</dd>
        <dt><code>--no-organize</code></dt>
        <dd>When set, this will not organize source files into the <a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md">PSR-0</a> autoloader-acceptable filesystem structure</dd>
        <dt><code>--no-php-lib</code></dt>
        <dd>Exclude the php.d.ts PHP definitions</dd>
        <dt><code>--no-type-hint</code></dt>
        <dd>Do not type hint emitted functions in any way</dd>
        <dt><code>-o</code>, <code>--out PATH</code></dt>
        <dd>When <code>--single</code> is present or there is only a single file on the command line, this is the single file to output to. References in the file are emitted relative to this single file path when not using <code>--single</code>. Otherwise, this is the directory to put all files at relative to the files given.</dd>
        <dt><code>--prefer-single-quotes</code></dt>
        <dd>When set, this will try to use single quotes for all strings that don't have escape characters</dd>
        <dt><code>--require-references</code></dt>
        <dd>When set, all <code>///&lt;reference /></code> will become <code>require_once</code>. This is only allowed when <code>--no-organize</code> is set.</dd>
        <dt><code>--single</code></dt>
        <dd>Compile all files to a single PHP file. This is basically also setting <code>--no-organize</code> also, so both cannot be present.</dd>
        <dt><code>--type-brace-newline</code></dt>
        <dd>Put the opening brace of classes and interfaces on the next line</dd>
        <dt><code>--use-else-if</code></dt>
        <dd>When an "else if" is encountered in Pratphall, translate to "else if" instead of the default "elseif"</dd>
        <dt><code>--verbose</code></dt>
        <dd>Log extra information on compile</dd>
        <dt><code>-w</code>, <code>--watch</code></dt>
        <dd>Re-compile all files on any file changes (including referenced files). Note, if not using <code>--single</code> this means files and directories created during compilation may be deleted on later compilation. Files are not overwritten if their output contents didn't change. Finally note this does not always work over remotely mounted filesystems.</dd>
        <dt><code>--watch-debounce-ms MS</code></dt>
        <dd>The number of milliseconds to wait for file change events to stop before re-compilation. The default is 1500 (1.5 seconds).</dd>
      </dl>

      <span class="bookmark" id="Manual-Types"></span>
      <h3 class="para-link">Types <a href="#Manual-Types">&nbsp;&para;</a></h3>

      <span class="bookmark" id="Manual-Types-Booleans"></span>
      <h4 class="para-link">Booleans <a href="#Manual-Types-Booleans">&nbsp;&para;</a></h4>
      <p>Booleans and conversions happen the same way in Pratphall as they do in PHP.</p>

      <span class="bookmark" id="Manual-Types-Strings"></span>
      <h4 class="para-link">Strings <a href="#Manual-Types-Strings">&nbsp;&para;</a></h4>
      <p>
        Strings in Pratphall and PHP are somewhat similar. There are no multiline strings. There is no string interpolation (attempts are escaped). Usually, the preference of single quote or double quote in the Pratphall script is translated verbatim to PHP. However, if there is an escape character in a single-quoted string, it will become double quoted. To request that all strings without escape characters to become single quoted in PHP, use the <code>--prefer-single-quotes</code> compiler option.
      </p>
      <p>
        In Pratphall strings are concatenated with a plus sign. In PHP the dot operator is used. Type inference is used to determine when this translation should occur. In Pratphall, if either side of the plus operator is a string, concatenation is assumed. If either side of a plus operator is an unknown/any type a normal arithmetic plus will be used and a compiler warning will be issued.
      </p>
      <p>Normal JavaScript string functions are translated to common PHP idioms with some <a href="#Manual-Appendices-Gotchas">gotchas</a>.</p>
      <div class="code">
        <pre><code data-language="javascript">//will be converted to double quotes
var a = 'My\nNewline\nString$escaped{$interpolation}';

//concatenation
var b = 99 + ' bottles of beer on the wall';

//compiler warning because type is any
var c: any = 'test string';
var d = 12 + c;

//common JS functions
var_dump(b.length);
var_dump(b.charAt(0));
var_dump(b.split(' '));</code></pre>
        <pre><code data-language="php">//will be converted to double quotes
$a = "My\nNewline\nString\$escaped{\$interpolation}";

//concatenation
$b = 99 . ' bottles of beer on the wall';

//compiler warning because type is any
$c = 'test string';
$d = 12 + $c;

//common JS functions
var_dump(strlen($b));
var_dump($b[0]);
var_dump(explode(' ', $b));</code></pre>
      </div>

      <span class="bookmark" id="Manual-Types-IntFloat"></span>
      <h4 class="para-link">Integers/Floats <a href="#Manual-Types-IntFloat">&nbsp;&para;</a></h4>
      <p>
        In JS there is no difference between an integer and a float for the most part, and the same is true in Pratphall. Conversion and testing can still occur at runtime with intval, floatval, and other methods. At compile time however, they are simply numbers. There is no normal way to constrain a variable on one type or the other. Hexadecimal and octal literals are translated to normal decimal integers during translation.
      </p>

      <span class="bookmark" id="Manual-Types-Arrays"></span>
      <h4 class="para-link">Arrays <a href="#Manual-Types-Arrays">&nbsp;&para;</a></h4>
      <p>
        Unlike PHP, Pratphall differentiates between associative arrays and normal indexed arrays. The former is of type <code>Pct.PhpAssocArray</code> whereas the latter is a normal JS array. This can be confusing at first, but in practice it helps the developer make more accurate assumptions about the typing of variables. You can convert between these types at compile time using <code>Pct.toAssocArray</code> or <code>Pct.toArray</code>. Note when using the latter, (until TypeScript has generics) the result is <code>any[]</code> so it is recommended to cast it to the exact form of array expected.
      </p>
      <p>
        Associative arrays can be created with <code>Pct.newAssocArray</code>. Only object literals can be passed to the function. Indexed arrays are handled almost exactly like they are in JS. They are created with the normal bracketed syntax.
      </p>
      <p>
        Normal JavaScript array functions are translated to common PHP idioms with a few <a href="#Manual-Appendices-Gotchas">gotchas</a>.
      </p>
      <div class="code">
        <pre><code data-language="javascript">//regular array
var a = [1, 2, 3];

//some calls
a.forEach((value: number) {
    var_dump(value);
});
a.push(4);

//associative array
var b = Pct.newAssocArray({
    prop: 'propValue',
    prop2: ['a', 'b', 'c'],
    closure: function () { echo('Hey!\n'); }
});

//some calls
var c = b.map((value: any) => {
    return gettype(value);
});
c['prop3'] = 15;
var_dump(c.length);</code></pre>
        <pre><code data-language="php">//regular array
$a = [1, 2, 3];

//some calls
foreach ($a as $value) {
    var_dump($value);
}
$a[] = 4;

//associative array
$b = [
    'prop' => 'propValue',
    'prop2' => ['a', 'b', 'c'],
    'closure' => function () { echo("Hey!\n"); }
];

//some calls
$c = array_map(function ($value) {
    return gettype($value);
}, $b);
$c['prop3'] = 15;
var_dump(count($c));</code></pre>
      </div>

      <span class="bookmark" id="Manual-Types-Objects"></span>
      <h4 class="para-link">Objects <a href="#Manual-Types-Objects">&nbsp;&para;</a></h4>
      <p>
        Objects in Pratphall and PHP work very similarly. Anonymous object literals become an stdClass via cast. Note, if you have a closure as an object property, it cannot necessarily be invoked like a method in PHP, so Pratphall has to do special handling (see <a href="#Manual-Appendices-Gotchas">GOTCHA-001</a>). TypeScript property accessors are not currently supported.
      </p>
      <div class="code">
        <pre><code data-language="javascript">var obj = {
    num: 12,
    arr: ['a', 'b', 'c'],
    obj: { innerNum: 12 },
    func: (value: string) => { echo('Value: ' + value); }
};</code></pre>
        <pre><code data-language="php">$obj = (object)[
    'num' => 12,
    'arr' => ['a', 'b', 'c'],
    'obj' => (object)[ 'innerNum' => 12 ],
    'func' => function ($value) { echo('Value: ' . $value); }
];</code></pre>
      </div>

      <span class="bookmark" id="Manual-Types-Resources"></span>
      <h4 class="para-link">Resources <a href="#Manual-Types-Resources">&nbsp;&para;</a></h4>
      <p>PHP resources are represented by the <code>Pct.PhpResource</code> type in Pratphall.</p>

      <span class="bookmark" id="Manual-Types-NullUndefined"></span>
      <h4 class="para-link">Null and Undefined <a href="#Manual-Types-NullUndefined">&nbsp;&para;</a></h4>
      <p>Null is handled the same way in Pratphall and PHP.</p>
      <p>
        Undefined is different. In Pratphall, <code>delete</code> translates directly to <code>unset</code>. Conditions that check typeof <code>undefined</code> are translated to safe PHP that avoids false positives with NULL values unlike isset.
      </p>
      <p>
        Functions isset and empty are used like any other PHP function in Pratphall. Since these are language constructs, the values don't necessarily have to exist like they do in JS.
      </p>
      <div class="code">
        <pre><code data-language="javascript">//normal null
var a = { prop1: null };
echo('a.prop1 null? ' + (a.prop1 == null));

//undefined
delete a.prop1;
echo('a.prop1 set? ' + (typeof a.prop1 == 'undefined'));</code></pre>
        <pre><code data-language="php">//normal null
$a = (object)[ 'prop1' => null ];
echo('a.prop1 null? ' . ($a->prop1 == null));

//undefined
unset($a->prop1);
echo('a.prop1 set? ' . (!array_key_exists('prop1', $a)));</code></pre>
      </div>

      <span class="bookmark" id="Manual-Types-Callbacks"></span>
      <h4 class="para-link">Callbacks <a href="#Manual-Types-Callbacks">&nbsp;&para;</a></h4>
      <p>
        Pratphall supports full typed closure type definitions instead of just the callable type hint in PHP. Even methods of objects can be passed around like normal.
      </p>
      <div class="code">
        <pre><code data-language="javascript">class Foo {
    bar(value: string) { echo('Value: ' + value); }
}

var foo = new Foo();
var f = foo.bar;
//call
f('test');</code></pre>
        <pre><code data-language="php">class Foo {
    public function bar($value) { echo('Value: ' . $value); }
}

$foo = new Foo();
$f = (new ReflectionMethod('Foo', 'bar'))->getClosure($foo);
//call
$f('test');</code></pre>
      </div>
      <p>
        This is safe since unlike PHP, Pratphall does not support naming properties/variables and methods/functions the same name. See <a href="#Manual-Appendices-Gotchas">GOTCHA-002</a> about interoperating with existing PHP that does.
      </p>

      <span class="bookmark" id="Manual-Types-Pseudo"></span>
      <h4 class="para-link">Pseudo-types <a href="#Manual-Types-Pseudo">&nbsp;&para;</a></h4>
      <p>
        Void can be used for return types of functions. There is no such thing as <code>mixed</code>, but there is <code>any</code> which loosely translates. The use of the <code>any</code> type should be avoided when possible. If using <code>any</code>, you are encouraged to cast to a known type as soon as you can.
      </p>

      <span class="bookmark" id="Manual-Types-Casting"></span>
      <h4 class="para-link">Casting <a href="#Manual-Types-Casting">&nbsp;&para;</a></h4>
      <p>
        To cast to a value at compile time, use the TypeScript method. For example: <code>&lt;bool>&lt;any>stringValue</code> casts a string to a bool but will not be casted in the emitted PHP code. This is helpful for functions that return a value or FALSE. In fact, this is such a common pattern that there are compile-time helpers for it: <code>Pct.isFalse</code> and <code>Pct.isNotFalse</code>.
      </p>
      <p>
        To cast a value at runtime, it is always preferred to use the built-in PHP methods such as `strval`, `intval`, etc. If you must have a literal cast, you can use the `Pct.cast*` functions.
      </p>
      <div class="code">
        <pre><code data-language="javascript">function printNumber(value: number) {
    echo('Number: ' + value + '\n');
}

//compile-time cast only
printNumber(&lt;number>&lt;any>'10');

//runtime PHP function cast
printNumber(intval('10'));

//runtime PHP explicit cast
printNumber(Pct.castInt('10'));

//two ways to check a FALSE return
if (&lt;bool>&lt;any>strpos('team', 'I') === false) {
    echo('There is no "I" in "team"\n');
}
if (Pct.isFalse(strpos('team', 'I'))) {
    echo('There is no "I" in "team"\n');
}</code></pre>
        <pre><code data-language="php">function printNumber($value) {
    echo('Number: ' . $value . "\n");
}

//compile-time cast only
printNumber('10');

//runtime PHP function cast
printNumber(intval('10'));

//runtime PHP explicit cast
printNumber(((int) '10'));

//two ways to check a FALSE return
if (strpos('team', 'I') === false) {
    echo("There is no \"I\" in \"team\"\n");
}
if (strpos('team', 'I') === false) {
    echo("There is no \"I\" in \"team\"\n");
}</code></pre>
      </div>

      <span class="bookmark" id="Manual-Syntax"></span>
      <h3 class="para-link">Syntax <a href="#Manual-Syntax">&nbsp;&para;</a></h3>

      <span class="bookmark" id="Manual-Syntax-Variables"></span>
      <h4 class="para-link">Variables <a href="#Manual-Syntax-Variables">&nbsp;&para;</a></h4>
      <p>Variables names are case sensitive and are NOT prefixed with dollar signs (except for references, see later).</p>
      <p>
        All variables in Pratphall are defined somewhere. If they are declared globally and are used in a function, the <code>global</code> keyword is applied in the translated PHP. There is no Pratphall equivalent to the static variable in PHP (not to be confused with the static property/function of a class).
      </p>
      <div class="code">
        <pre><code data-language="javascript">var a = 'myGlobalString';

function printGlobalString() {
    /*blank space here for clarity*/
    echo('Global string: ' + a);
}</code></pre>
        <pre><code data-language="php">$a = 'myGlobalString';

function printGlobalString() {
    global $a;
    echo('Global string: ' + $a);
}</code></pre>
      </div>
      <p>
        "Variable variables" are not supported in Pratphall in any way. The best you can do is access an object's property by its string-based name using the bracket syntax.
      </p>
      <div class="code">
        <pre><code data-language="javascript">var obj = { child: { grandchild: 5 }};
echo('Grandchild val: ' + obj.child['grand' + 'child']);</code></pre>
        <pre><code data-language="php">$obj = (object)[ 'child' => (object)[ 'grandchild' => 5 ]];
echo('Grandchild val: ' . $obj->child->{'grand' . 'child'});</code></pre>
      </div>

      <span class="bookmark" id="Manual-Syntax-Constants"></span>
      <h4 class="para-link">Constants <a href="#Manual-Syntax-Constants">&nbsp;&para;</a></h4>
      <p>
        By default in Pratphall, variable names that are completely capitalized are assumed to be constant and variables that are not are assumed to be normally named. To override this behavior, use <code>Pct.const</code> or <code>Pct.asVar</code> when referencing the variable to change Pratphall's default. Note, the superglobals <code>GLOBALS</code>, <code>_SERVER</code>, <code>_GET</code>, <code>_POST</code>, <code>_FILES</code>, <code>_COOKIE</code>, <code>_SESSION</code>, <code>_REQUEST</code>, and <code>_ENV</code> are all automatically known by Pratphall to be prefixed with dollar signs.
      </p>

      <span class="bookmark" id="Manual-Syntax-Operators"></span>
      <h4 class="para-link">Operators <a href="#Manual-Syntax-Operators">&nbsp;&para;</a></h4>
      <p>
        All operators work the same in Pratphall and PHP with the following exceptions:
        <dl class="heading-list">
          <dt><code>clone</code></dt>
          <dd>
            The Pratphall language has no keyword for clone. You can get the same effect by using <code>Pct.clone</code>
            <div class="code-nested">
              <pre><code data-language="javascript">var obj = { foo: 'bar' };
var copy = Pct.clone(obj);</code></pre>
              <pre><code data-language="php">$obj = (object)[ 'foo' => 'bar' ];
$copy = clone $obj;</code></pre>
            </div>
          </dd>
          <dt><code>.</code></dt>
          <dd>
            String concatenation is done via <code>+</code> and translated based on type inference. Same goes for <code>.=</code> in PHP which is <code>+=</code> in Pratphall.
          </dd>
          <dt><code>and</code>, <code>xor</code>, <code>or</code></dt>
          <dd>Completely unsupported in Pratphall (not to be confused with support for <code>&amp;&amp;</code> and <code>||</code>).</dd>
          <dt><code>&gt;&gt;&gt;</code></dt>
          <dd>PHP does not have a zero-fill right shift, so the presence of this operator in Pratphall will cause a compiler error</dd>
          <dt><code>?:</code></dt>
          <dd>Pratphall supports the normal PHP ternary, but does not support the shorthand form which uses the conditional as the first result.</dd>
          <dt><code>&amp;</code></dt>
          <dd>References types and reference assignment are handled differently in Pratphall. See the References section.</dd>
          <dt><code>&lt;&gt;</code></dt>
          <dd>This is considered "not equal" in PHP. Pratphall does not support it.</dd>
          <dt><code>@</code></dt>
          <dd>
            The <code>@</code> symbol may not be used to swallow errors in Pratphall. If you must swallow errors, use <code>Pct.swallowErrors</code> (unwieldy name on purpose) which will use the <code>@</code> sign.
            <div class="code-nested">
              <pre><code data-language="javascript">var f = Pct.swallowErrors(file('not-here.txt'));</code></pre>
              <pre><code data-language="php">$f = @file('not-here.txt');</code></pre>
            </div>
          </dd>
          <dt><code>`</code></dt>
          <dd>Backticks are unsupported in Pratphall. Use shell_exec if you must.</dd>
          <dt><code>+</code></dt>
          <dd>
            Addition with numbers works normally. Unioning arrays, if you must, is done with <code>Pct.unionArray</code>. Note, this comes back with <code>any[]</code> if you are using an indexed array, so please cast immediately back to what you expect it to be.
            <div class="code-nested">
              <pre><code data-language="javascript">var a = &lt;number[]>Pct.unionArray([1, 2, 3], [4, 5, 6, 7]);</code></pre>
              <pre><code data-language="php">$a = [1, 2, 3] + [4, 5, 6, 7];</code></pre>
            </div>
          </dd>
          <dt><code>==</code>, <code>!=</code>, <code>===</code></dt>
          <dd>
            These translate directly, but it's important to understand that TypeScript/JS and PHP don't treat array or object equality the same, so be careful when writing shareable code comparing arrays or objects.
          </dd>
          <dt><code>instanceof</code></dt>
          <dd>
            This check will work just fine in Pratphall when the right hand side is the literal name of a class. If the right hand side is a string, interface, or some other expression you must use <code>Pct.isInstance</code>. Of course, <code>is_a</code> may be also be used as part of the PHP standard library.
            <div class="code-nested">
              <pre><code data-language="javascript">class Foo { }
var a = new Foo();
var b = Pct.isInstance(a, 'Foo');</code></pre>
              <pre><code data-language="php">class Foo { }
$a = new Foo();
$b = a instanceof 'Foo';</code></pre>
            </div>
          </dd>
          <dt><code>typeof</code></dt>
          <dd>
            This has no operator/construct equivalent in PHP, but it is automatically translated to gettype (except for as used for checks with undefined). Note, the results can differ between JS and PHP, so make sure you code to the PHP environment or abstract when writing shareable code.
          </dd>
        </dl>
      </p>

      <span class="bookmark" id="Manual-Syntax-ControlStructures"></span>
      <h4 class="para-link">Control Structures <a href="#Manual-Syntax-ControlStructures">&nbsp;&para;</a></h4>
      <p>
        All control structures work the same in Pratphall and PHP with the following exceptions:
        <dl class="heading-list">
          <dt><code>elseif</code></dt>
          <dd>
            Use <code>else if</code> in Pratphall which will translate to <code>elseif</code> in PHP by default. The <code>--use-else-if</code> compiler option can be used to emit <code>else if</code> instead.
          </dd>
          <dt>
            <code>if():</code>, <code>elseif:</code>, <code>else:</code>, <code>endif;</code>, <code>while:</code>, <code>endwhile;</code>, <code>for:</code>, <code>endfor;</code>, <code>foreach:</code>, <code>endforeach;</code>, <code>switch:</code>, <code>endswitch;</code>
          </dt>
          <dd>Unsupported in Pratphall</dd>
          <dt><code>for...in</code></dt>
          <dd>
            This JS concept isn't present in any way in PHP and isn't worth the significant runtime code to support accurately. If this is seen, a compiler warning is issued and it's translated to a foreach of <code>array_keys</code> of an array cast which is not the exact same thing. These loops are discouraged.
            <div class="code-nested">
              <pre><code data-language="javascript">var a = { b: 1, c: 2 };
for (b in a) {
    echo('a[' + b + ']: ' + a[b] + '\n');
}</code></pre>
              <pre><code data-language="php">$a = (object)[ 'b' => 1, 'c' => 2 ];
foreach (array_keys($a) as $b) {
    echo('a[' . $b . ']: ' . $a->{$b} . "\n");
}</code></pre>
            </div>
          </dd>
          <dt><code>foreach</code></dt>
          <dd>
            This is represented in Pratphall by the <code>forEach</code> function that can be called on an iterable object or an array. If the function passed to <code>forEach</code> is an inline closure, it will be translated directly. Otherwise, it will be translated to an <code>array_walk</code> call.
            <div class="code-nested">
              <pre><code data-language="javascript">var a = Pct.newAssocArray({ b: 1, c: 2 });

//regular
a.forEach((value: number, index: string) => {
    echo('a[' + index + ']: ' + value + '\n');
});

//callback
var d = (value: number, index: string) => {
    echo('a[' + index + ']: ' + value + '\n');
};
a.forEach(d);</code></pre>
              <pre><code data-language="php">$a = (object)[ 'b' => 1, 'c' => 2 ];

//regular
foreach ($a as $index => $value) {
    echo('a[' + $index + ']: ' + $value + "\n");
}

//callback
$d = function ($value, $index) {
    echo('a[' + $index + ']: ' + $value + "\n");
};
array_walk($a, $d);</code></pre>
            </div>
          </dd>
          <dt><code>break #</code>, <code>continue #</code></dt>
          <dd>
            In Pratphall, break and continue statements are optionally associated with labels instead of a number. Normal breaks and continues in Pratphall work as normal. When a label is defined though, the construct becomes a goto. There is no equivalent for PHP's numbered break and continue statements. For example, `outside: while (a) { while (b) { break outside; } }` translates to `outside: while ($a) { while ($b) { goto outside; } }`.
            <div class="code-nested">
              <pre><code data-language="javascript">var counter = 0;
again:
var lines = file('file' + (++counter) + '.txt');
for (var i = 0; i &lt; lines.length; i++) {
  var words = lines[i].split(' ');
  for (var j = 0; j &lt; words.length; j++) {
      var word = words[j];
      if (word == 'end') break done;
      else if (word == 'nextfile') break again;
      else echo('Word: ' + word + '\n');
  }
}
done:
echo('Done!\n');</code></pre>
              <pre><code data-language="php">$counter = 0;
again:
$lines = file('file' + (++$counter) + '.txt');
for ($i = 0; $i &lt; count($lines); $i++) {
  $words = explode(' ', lines[$i]);
  for ($j = 0; $j &lt; count($words); $j++) {
      $word = $words[$j];
      if ($word == 'end') goto done;
      elseif ($word == 'nextfile') goto again;
      else echo('Word: ' . $word . "\n");
  }
}
done:
echo("Done!\n");</code></pre>
            </div>
          </dd>
          <dt><code>declare</code></dt>
          <dd>
            Not a construct in Pratphall, but can be called using <code>Pct.declare</code>. If a function is the last parameter of the call, it considers code within to be in a declare block.
          </dd>
          <dt><code>return</code></dt>
          <dd>Return from methods/functions works normally. Global return statements are unsupported</dd>
          <dt><code>include</code>, <code>include_once</code>, <code>require</code>, <code>require_once</code></dt>
          <dd>
            These are normal functions, but do not affect type checking. In order to affect type-checking, you must use <code>///&lt;reference /></code> elements at the top of your file. If the <code>--require-references</code> compiler option is set, reference elements will become <code>require_once</code> calls.
          </dd>
          <dt><code>goto</code></dt>
          <dd>Unsupported in Pratphall</dd>
        </dl>
      </p>

      <span class="bookmark" id="Manual-Syntax-References"></span>
      <h4 class="para-link">References <a href="#Manual-Syntax-References">&nbsp;&para;</a></h4>
      <p>
        Pratphall recommends avoiding references. If you cannot, they are supported.
      </p>
      <p>
        To assign by reference or otherwise reference, use <code>Pct.byRef</code>.
      </p>
      <p>
        To pass by reference, the parameter in the function must start with a dollar sign. A compiler error occurs if the item passed by reference is not valid (e.g. expressions or literals).
      </p>
      <p>
        To return by reference, the function name must start with a dollar sign. Also, to receive the returned result as a reference, you must call <code>Pct.byRef</code>.
      </p>
      <div class="code">
        <pre><code data-language="javascript">//assign
var a = 'hey';
var b = Pct.byRef(a);
//pass
function addWord($val: string) {
    $val += ' word';
}
addWord(b);
echo('Changed? ' + (a == 'hey word'));
//return
var c = { d: 15 };
function $getReference(val: { d: number; }) {
    return val.d;
}
var e = Pct.byRef($getReference(c));
e = 20;
echo('Changed? ' + (c.d == 20));</code></pre>
        <pre><code data-language="php">//assign
$a = 'hey';
$b = &amp;$a;
//pass
function addWord(&amp;$val) {
    $val .= ' word';
}
addWord($b);
echo('Changed? ' . ($a == 'hey word'));
//return
$c = (object)['d' => 15];
function &amp;getReference($val) {
    return $val->d;
}
$e = &amp;getReference($c);
$e = 20;
echo('Changed? ' . ($c->d == 20));</code></pre>
      </div>

      <span class="bookmark" id="Manual-Structure"></span>
      <h3 class="para-link">Structure <a href="#Manual-Structure">&nbsp;&para;</a></h3>

      <span class="bookmark" id="Manual-Structure-FunctionBasics"></span>
      <h4 class="para-link">Function Basics <a href="#Manual-Structure-FunctionBasics">&nbsp;&para;</a></h4>
      <p>
        Functions in Pratphall behave very similarly to PHP.
      </p>
      <p>
        Overloads declarations are allowed in Pratphall like they are in TypeScript, but only one "catch all" function with an implementation is allowed. The overloaded signatures will be discarded.
      </p>
      <p>
        Type hinting is done by default for arrays, callables, and actual type declarations. Parameters who are typed with compile time only types (see compile time declarations below) will not be type hinted. If the compiler option <code>--no-type-hint</code> is set, type hinting will not be present on any function.
      </p>

      <span class="bookmark" id="Manual-Structure-VariadicFunctions"></span>
      <h4 class="para-link">Variadic Functions <a href="#Manual-Structure-VariadicFunctions">&nbsp;&para;</a></h4>
      <p>
        Pratphall directly supports typed variadic function arguments (known as "RestParameters" in the TypeScript specification) whereas PHP does not. The use of variadic functions is not encouraged, but supported.
      </p>
      <p>
        When the <code>arguments</code> array is referenced in a function, it is translated to PHP by using <code>func_get_args</code> (see <a href="#Manual-Appendices-Gotchas">GOTCHA-003</a> about re-defining arguments). When a rest parameter is used as a parameter in a function, it is derived from <code>func_get_args</code>
      </p>
      <div class="code">
        <pre><code data-language="javascript">function myprint(one: string, ...args: any[]) {
    /* left blank to make comparison easier */

    echo('First: ' + arguments[0] + '\n');
    echo('Last: ' + arguments[arguments.length - 1] + '\n');
    if (args.length > 0) {
        echo('First args: ' + args[0] + '\n');
        echo('Last args: ' + args[args.length - 1] + '\n');
    }
}

myprint('foo', true, 13.5, 'bar');</code></pre>
        <pre><code data-language="php">function myprint($one) {
    $arguments = func_get_args();
    $args = array_slice(func_get_args(), 1);
    echo('First: ' . $arguments[0] + "\n");
    echo('Last: ' . $arguments[count($arguments) - 1] . "\n");
    if (count($args) > 0) {
        echo('First args: ' . $args[0] . '\n');
        echo('Last args: ' . $args[count($args) - 1] . "\n");
    }
}

myprint('foo', true, 13.5, 'bar');</code></pre>
      </div>

      <span class="bookmark" id="Manual-Structure-OptionalParameters"></span>
      <h4 class="para-link">Optional Function Parameters <a href="#Manual-Structure-OptionalParameters">&nbsp;&para;</a></h4>
      <p>
        Both PHP and Pratphall support optional function parameters. PHP supports only default parameters with only scalars/arrays and they can be anywhere within the parameter list. Pratphall supports both optional and default parameters which can be initialized to any type and must be at the end of the parameter list.
      </p>
      <p>
        Optional parameters in Pratphall without a default value are assumed to be null. If the default parameter is specified and it is not a constant, scalar value, it will be set at the beginning of the function (this practice is usually discouraged).
      </p>
      <div class="code">
        <pre><code data-language="javascript">function words(prefix?: bool, file = file('default.txt')) {
    /* left blank to make comparison easier */
    file.forEach((line: string) => {
        line.split(' ').forEach((word: string) => {
            if (prefix) echo('Word: ');
            echo(word + '\n');
        });
    });
}

//reads default.txt and prints w/out prefix
words();
//uses array and prints w/ prefix
words(true, ['foo bar', 'fu bar']);</code></pre>
        <pre><code data-language="php">function words($prefix = false, $file = null) {
    if ($file === null) $file = file('default.txt');
    foreach ($file as $line) {
        foreach (explode(' ', $line) as $word) {
            if ($prefix) echo('Word: ');
            echo($word . "\n");
        }
    }
}

//reads default.txt and prints w/out prefix
printWords();
//uses array and prints w/ prefix
printWords(true, ['foo bar', 'fu bar']);</code></pre>
      </div>

      <h4>Anonymous and Nested Functions</h4>
      <p>
        Pratphall and PHP have support for anonymous functions with a common syntax and are invoked and passed the same way.
      </p>
      <p>
        PHP's parser supports nested functions, but it places them in the global scope. Pratphall does NOT support these nested functions. When Pratphall encounters a nested function, it treats it like an anonymous function assigned to the variable of the same name. This means the compiler will error if a variable and nested function appear in the same function with the same name.
      </p>
      <div class="code">
        <pre><code data-language="javascript">function func() {
    var anonFunc = (value: string) => { echo(value); }
    var anonFunc2 = function (value: string) { echo(value); }
    function nestedFunc(value: string) { echo(value); }
}</code></pre>
        <pre><code data-language="php">function func() {
    $anonFunc = function ($value) { echo($value); };
    $anonFunc2 = function ($value) { echo($value); };
    $nestedFunc = function ($value) { echo($value); };
}</code></pre>
      </div>

      <span class="bookmark" id="Manual-Structure-TryCatch"></span>
      <h4 class="para-link">Try/Catch <a href="#Manual-Structure-TryCatch">&nbsp;&para;</a></h4>
      <p>
        Pratphall's (ahem, JS's) native try/catch syntax is much more limited than PHP's. It is supported and will even emit PHP 5.5 finally statements. You can compile-time cast the catch variable or do an instanceof check.
      </p>
      <div class="code">
        <pre><code data-language="javascript">try {
    new ReflectionClass('NonExistentClass');
} catch (err) {
    if (err instanceof ReflectionException) {
        echo('Not found: ' + (&lt;Exception>err).getMessage());
    } else {
        echo('Other: ' + (&lt;Exception>err).getMessage());
    }
} finally {
    echo('This runs always in PHP 5.5');
}</code></pre>
        <pre><code data-language="php">try {
    new ReflectionClass('NonExistentClass');
} catch (Exception $err) {
    if ($err instanceof ReflectionException) {
        echo('Not found: ' . $err->getMessage());
    } else {
        echo('Other: ' . $err->getMessage());
    }
} finally {
    echo('This runs always in PHP 5.5');
}</code></pre>
      </div>
      <p>
        Pratphall does include compile-time helpers to support the full try/catch syntax via <code>Pct.try</code>. It is an object literal w/ a try function, an optional catch function (or array of functions), and an optional finally function. If neither a catch nor finally is supplied, it assumes an empty catch statement.
      </p>
      <div class="code">
        <pre><code data-language="javascript">Pct.try({
    try: () => {
        new ReflectionClass('NonExistentClass');
    },
    catch: [
        (err: ReflectionException) => {
            echo('Not found: ' + err.getMessage());
        },
        (err: Exception) => {
            echo('Other: ' + err.getMessage());
        }
    ],
    finally: () => {
        echo('This runs always in PHP 5.5');
    }
});</code></pre>
        <pre><code data-language="php">try {
    new ReflectionClass('NonExistentClass');
} catch (ReflectionException $err) {
    echo('Not found: ' . $err->getMessage());
} catch (Exception $err) {
    echo('Other: ' . $err->getMessage());
} finally {
    echo('This runs always in PHP 5.5');
}</code></pre>
      </div>

      <span class="bookmark" id="Manual-Structure-ClassInterface"></span>
      <h4 class="para-link">Classes and Interfaces <a href="#Manual-Structure-ClassInterface">&nbsp;&para;</a></h4>
      <p>
        Pratphall supports classes and interfaces just like PHP. There are several features that Pratphall does not support:
        <ul>
          <li>
            <strong>abstract</strong> - No abstract members or classes are supported. There is no equivalent. (future possibility, see <a href="http://typescript.codeplex.com/workitem/395">TS-395</a> or maybe find some other way w/ function sigs in classes)
          </li>
          <li>
            <strong>class constants</strong> - By default in Pratphall, only completely capitalized properties are assumed constant. There is no way to create a property that is a constant that isn't completely capitalized and there is no way to create a property that is not a constant that is completely capitalized. For interoperating with existing code that violates the all-caps-are-consts rule, you must use <code>Pct.const</code> or <code>Pct.asVar</code> when referencing them. (future possibility, see <a href="http://typescript.codeplex.com/workitem/368">TS-368</a>)
          </li>
          <li>
            <strong>protected</strong> - There simply is no equivalent. When making ambient declarations to interoperate with existing PHP code, choose private or public depending on whether you plan to inherit. (future possibility, see <a href="http://typescript.codeplex.com/workitem/125">TS-125</a>)
          </li>
          <li>
            <strong>traits</strong> - No equivalent. To interoperate with code that uses traits, just use interfaces. (future possibility if TypeScript supports mixins)
          </li>
          <li>
            <strong>property accessors</strong> - No equivalent. (future possibility, see <a href="https://wiki.php.net/rfc/propertygetsetsyntax-v1.2">PHP RFC</a>)
          </li>
          <li>
            <strong>final</strong> - No equivalent. (future possibility, see <a href="http://typescript.codeplex.com/workitem/352">TS-352</a>)
          </li>
          <li>
            <strong>self/static</strong> - Cannot use <code>self::</code> or <code>static::</code> to reference static members. Instead, you must use the class name explicitly. This means there is no late static binding. (future possibility, have a compile-time helper like <code>Pct.self</code> or <code>Pct.static</code>)
          </li>
        </ul>
        Despite these non-existent features, the Pratphall object-oriented system is very strong. Actually, in practice we've found the absence of some of these features leads to cleaner code. Here are some features that Pratphall does support:
        <ul>
          <li>
            <strong>constructors</strong> - Use <code>constructor</code> in Pratphall which translates to <code>__construct</code>. A member named <code>__construct</code> in Pratphall is an error. Also, using public or private before variable declarations in a constructor automatically make them properties.
          </li>
          <li>
            <strong>public by default</strong> - All members are public by default.
          </li>
          <li>
            <strong>interface properties</strong> - Interfaces can define properties that the class needs to end up defining. Note, these are NOT emitted to PHP, they are a compile-time only feature.
          </li>
          <li>
            <strong>super calls</strong> - To call a parent method inside an overload, use <code>super</code> which is translated to <code>parent</code> in PHP.
          </li>
          <li>
            <strong>overloads</strong> - Overloaded methods are supported in classes just like normal overloaded functions. This means there must be a single catch-all implementation and the overload signatures are not emitted.
          </li>
          <li>
            <strong>callable class</strong> - When calling the class or passing around the class as a callable closure, simply pass around a reference to <code>__invoke</code> and it will automatically be removed. Until bare call signature implementations are supported in classes, you cannot call the class as a function directly.
          </li>
          <li>
            <strong>toString</strong> - In Pratphall, <code>toString</code> becomes <code>__toString</code>. A member named <code>__toString</code> in Pratphall is an error.
          </li>
          <li>
            <strong>property initialization</strong> - In Pratphall a property (static or not) may be initialized in any way unlike PHP which requires a constant. If an instance property is initialized with a non-constant value, it is set in the constructor (if the constructor doesn't exist, it copies the base class constructor and defers to it). If a static property is initialized with a non-constant value, it is set just after the class declaration in PHP. Note, private static properties with non-constant initializers are set via reflection.
          </li>
          <li>
            <strong>optional members</strong> - In Pratphall, using a question mark after a function or property name in an interface means the implementer doesn't have to implement it. Optional members are NOT emitted to PHP, they are a compile-time only feature.
          </li>
          <li>
            <strong>magic methods</strong> - All magic methods besides <code>__construct</code> and <code>__toString</code> are supported as normal methods. If they are not public, an error occurs. Be advised, the compile-time type system is unaware of runtime-derived members from things like <code>__get</code>, <code>__callStatic</code>, etc. Pratphall discourages the use of these magic methods, but if you must, cast to any first then cast the result back.
          </li>
        </ul>
      </p>
      <div class="code">
        <pre><code data-language="javascript">//spacing added below for clarity
interface Iface {

    numberProperty: number;

    write(param: string);

    notRequired?(...params: any[]): bool;
}

class BaseClass {

    static fileContents = file_get_contents('myfile.txt');



    constructor(public numberProperty: number) {

        echo('Constructed!')
    }
}


class MyClass extends BaseClass implements Iface {

    static getFileContents() {
        return BaseClass.fileContents;
    }

    constructor() {
        super(12);
    }

    __destruct() { echo('Destructing!\n'); }

    private secretFunction() { echo('Hello\n'); }

    write(param: string) {
        echo('Value: ' + param + '\n');
    }

    __invoke(someVal: any) {
        echo('I have been invoked!\n');
        return this.numberProperty + Pct.castInt(someVal);
    }

    __get(prop: string) { return 42; }

    __set(prop: string, value: any) {
        echo('Setting ' + prop + ' with ' + value);
    }

    toString() { return 'MyClass'; }
}

var myClass = new MyClass();
echo('Instance? ' + (myClass instanceof Iface) + '\n');
//call static
var a = MyClass.getFileContents();
//call normal
myClass.write('Hey');
//invoke
var b = myClass.__invoke(20);
var c = myClass.__invoke('15');
//trigger getter/setter
var d = &lt;number&gt;(&lt;any&gt;myClass).someProp;
(&lt;any&gt;myClass).someNewProp = 20;
//string version
var e = myClass.toString();</code></pre>
        <pre><code data-language="php">//spacing added below for clarity
interface Iface {



    public function write($param);


}

class BaseClass {

    public static $fileContents;

    public $numberProperty;

    public function __construct($numberProperty) {
        $this->numberProperty = $numberProperty;
        echo('Constructed!');
    }
}
BaseClass::$fileContents = file_get_contents('myfile.txt');

class MyClass extends BaseClass implements Iface {

    public static function getFileContents() {
        return BaseClass::$fileContents;
    }

    public function __construct() {
        parent::__construct(12);
    }

    public function __destruct() { echo("Destructing!\n"); }

    private function secretFunction() { echo("Hello\n"); }

    public function write($param) {
        echo('Value: ' . $param . "\n");
    }

    public function __invoke($someVal) {
        echo("I have been invoked!\n");
        return $this->numberProperty + (int) $someVal;
    }

    public function __get($prop) { return 42; }

    public function __set($prop, $value) {
        echo('Setting ' . $prop . ' with ' . $value);
    }

    public function __toString() { return 'MyClass'; }
}

$myClass = new MyClass();
echo('Instance? ' . ($myClass instanceof Iface) . "\n");
//call static
$a = MyClass::getFileContents();
//call normal
$myClass->write('Hey');
//invoke
$b = $myClass(20);
$c = $myClass('15');
//trigger getter/setter
$d = $myClass->someProp;
$myClass->someNewProp = 20;
//string version
$e = strval($myClass);</code></pre>
      </div>

      <span class="bookmark" id="Manual-Structure-AmbientCompileTime"></span>
      <h4 class="para-link">Ambient and Compile-Time Declarations <a href="#Manual-Structure-AmbientCompileTime">&nbsp;&para;</a></h4>
      <p>
        Ambient class, interface, variable, and function declarations are not emitted with the PHP output. They are best suited for describing external code. To make a variable, class, or function ambient, simple use the <code>declare</code> keyword before it. To make an interface ambient, make the interface explicitly extend <code>Pct.Ambient</code>. Another way to make all of these ambient is to simply place them in a declaration file (which is a file that has the <code>.d.ts</code> extension). For example, here are the contents of <code>json.d.ts</code> which describes the <a href="http://php.net/manual/en/book.json.php">JSON</a> library:
      </p>
      <pre><code data-language="javascript">var JSON_ERROR_CTRL_CHAR: number;
var JSON_ERROR_DEPTH: number;
var JSON_ERROR_NONE: number;
var JSON_ERROR_STATE_MISMATCH: number;
var JSON_ERROR_SYNTAX: number;
var JSON_ERROR_UTF8: number;

var JSON_BIGINT_AS_STRING: number;
var JSON_FORCE_OBJECT: number;
var JSON_HEX_AMP: number;
var JSON_HEX_APOS: number;
var JSON_HEX_QUOT: number;
var JSON_HEX_TAG: number;
var JSON_NUMERIC_CHECK: number;
var JSON_PRETTY_PRINT: number;
var JSON_UNESCAPED_SLASHES: number;
var JSON_UNESCAPED_UNICODE: number;

interface JsonSerializable {
    jsonSerialize(): any;
}

function json_decode(json: string, assoc?: bool, depth?: number, options?: number): any;
function json_encode(value: any, options?: number): string;
function json_last_error(): number;</code></pre>
      <p>
        Since ambient types are still seen at runtime, they will be emitted as type hints. Compile-time declarations do not suffer from this. They are only there to enforce a certain contract and that's it. Only interfaces and classes can be marked compile-time only, and this is done by explicitly extending or implementing the <code>Pct.CompileTimeOnly</code> interface. Just because a super class/interface implements <code>Pct.CompileTimeOnly</code> doesn't mean it's children do, it must be explicitly stated.
      </p>
      <div class="code">
        <pre><code data-language="javascript">interface Place extends Pct.CompileTimeOnly {
    zip: string;
    city?: string;
}

interface Weather extends Pct.CompileTimeOnly {
    place: Place;
    temperature: number;
}

function printWeather(weather: Weather) {
    echo('It is ' + weather.temperature + ' in ');
    if (property_exists(weather.place, 'city')) {
        echo(weather.place.city);
    } else echo(weather.place.zip);
}

printWeather({
    place: {
        zip: '75001',
        city: 'Addison'
    },
    temperature: 85
});
printWeather({
    place: {zip: '76020'},
    temperature: 88
});</code></pre>
        <pre><code data-language="php">









function printWeather($weather) {
    echo('It is ' . $weather->temperature . ' in ');
    if (property_exists($weather->place, 'city')) {
        echo($weather->place->city);
    } else echo($weather->place->zip);
}

printWeather((object)[
    'place' => (object)[
        'zip' => '75001',
        'city' => 'Addison'
    ],
    'temperature' => 85
]);
printWeather((object)[
    'place' => (object)['zip' => '76020'],
    'temperature' => 88
]);</code></pre>
      </div>

      <span class="bookmark" id="Manual-Structure-Modules"></span>
      <h4 class="para-link">Modules and References <a href="#Manual-Structure-Modules">&nbsp;&para;</a></h4>
      <p>
        Modules in Pratphall are directly translatable as namespaces in PHP.
      </p>
      <p>
        Even though PHP namespaces cannot be nested, Pratphall modules can. When emitted to PHP, they are separated. The dots translate to slashes in PHP. When not in the global namespace, globally namespaced type references are automatically prefixed with a slash.
      </p>
      <p>
        If a module is imported with an alias, it is translated to a use statement. If the alias is the same as the last module part, the <code>as</code> alias in the use statement is not emitted. Currently, Pratphall can only import and alias other modules, there is no importing or aliasing of other classes/interfaces. The <code>namespace</code> operator to access something in the same module is not present in Pratphall.
      </p>
      <p>
        External module references that use <code>import mod = module('modname')</code> format cause a compiler warning and are ignored for now. Use of the export feature to share items amongst modules is strictly a compile-time feature and is not emitted to PHP.
      </p>
      <p>
        If you must reference code in another file, you can use <code>///&lt;reference path="PATH" /&gt;</code>. It is common practice to reference a file that might just be full of references to the other files in the project. This is just a compile-time reference unless both <code>--no-organize</code> and <code>--require-references</code> are set as compiler options.
      </p>
      <p>
        Different compiler options affect how the files are outputted. Below are descriptions of the options and output PHP examples based on these two files:
        <pre><code data-language="javascript">//file1.ts
module MyModule {
    export interface MyIface {
    }

    export module Sub {
        export class MyClass implements MyModule.MyIface {
            causeErr() {
                throw new Exception('Error');
            }
        }
    }
}

//file2.ts
///&lt;reference path="file1.ts" />
import Sub = MyModule.Sub;
var a = new Sub.MyClass();
a.causeErr();</code></pre>
        <dl class="heading-list">
          <dt>default</dt>
          <dd>
            By default, all classes and interfaces are written into their own file according to <a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md">PSR-0</a>. This means that except for the initial file passed to the compiler, no other files may have any top-level vars/functions or be in the global namespace.
            <pre><code data-language="php">//MyModule/MyIface.php
namespace MyModule;

interface MyIface {
}

//MyModule/Sub/MyClass.php
namespace MyModule\Sub;

class MyClass implements MyModule\MyIface
    public function causeErr() {
        throw new \Exception('Error');
    }
}

//file2.php
use MyModule\Sub;
$a = new Sub\MyClass();
$a->causeErr();</code></pre>
          </dd>
          <dt>with <code>--no-organize</code></dt>
          <dd>
            When this option is set, all emitted PHP files are the same name as the Pratphall source files (.ts files) but with PHP extensions. This cannot be used with <code>--single</code> since that option basically includes this option. This option allows top-level code in any file and allows any file to operate in the global namespace. This option is best used in conjunction with <code>--require-references</code>. When that option is set, the <code>///&lt;reference path="PATH" /&gt;</code> references become <code>require_once</code> calls in PHP.
            <pre><code data-language="php">//file1.php
namespace MyModule {

    interface MyIface {
    }

}

namespace MyModule\Sub {

    class MyClass implements MyModule\MyIface
        public function causeErr() {
            throw new \Exception('Error');
        }
    }

}

//file2.php
use MyModule\Sub;
$a = new Sub\MyClass();
$a->causeErr();</code></pre>
          </dd>
          <dt>with <code>--single</code></dt>
          <dd>
            When this option is set, all Pratphall code is emitted to a single PHP file. Like the default, this means that except for the initial file passed to the compiler, no other files may have any top-level vars/functions. However, any file can have contents in the global namespace. This cannot be used with <code>--no-organize</code>.
            <pre><code data-language="php">//file2.php
namespace MyModule {

    interface MyIface {
    }

}

namespace MyModule\Sub {

    class MyClass implements MyModule\MyIface
        public function causeErr() {
            throw new \Exception('Error');
        }
    }

}

namespace {
    use MyModule\Sub;
    $a = new Sub\MyClass();
    $a->causeErr();
}</code></pre>
          </dd>
        </dl>
      </p>

      <span class="bookmark" id="Manual-Metaprogramming"></span>
      <h3 class="para-link">Metaprogramming <a href="#Manual-Metaprogramming">&nbsp;&para;</a></h3>

      <span class="bookmark" id="Manual-Metaprogramming-Overview"></span>
      <h4 class="para-link">Overview <a href="#Manual-Metaprogramming-Overview">&nbsp;&para;</a></h3>
      <p>
        Pratphall includes the ability to write compile-time extensions that can emit PHP code, validate input, or do anything else. They are written in TypeScript (not Pratphall) and run during compilation in nodejs.
      </p>
      <p>
        Extensions utilize the AST structure built in to the TypeScript code base. The most common use of extensions is to emit PHP that isn't available in Pratphall. In fact, all of the <code>Pct</code> features are implemented as extensions and can be seen in the Pratphall source in the src/ext folder. For example, here is the extension source that turns <code>toString</code> calls in Pratphall to <code>strval</code> calls in PHP:
      </p>
      <pre><code data-language="javascript">///&lt;reference path='../pratphall.ts' />

module Pratphall {
    import TS = TypeScript;

    PhpEmitter.registerExtension({
        name: 'Object.toString emitter',
        description: 'Make it strval',
        matcher: {
            nodeType: [TS.NodeType.Call],
            priority: 1,
            propertyMatches: {
                target: (value: TS.AST): bool => {
                    return value instanceof TS.BinaryExpression &amp;&amp;
                        value.nodeType == TS.NodeType.Dot &amp;&amp;
                        (&lt;TS.BinaryExpression>value).operand2 instanceof TS.Identifier &amp;&amp;
                        (&lt;TS.Identifier>(&lt;TS.BinaryExpression>value).operand2).text == 'toString';
                }
            }
        },
        emit: (ast: TS.CallExpression, emitter: PhpEmitter): bool => {
            emitter.write('strval(').emit((&lt;TS.BinaryExpression>ast.target).operand1).write(')');
            return true;
        }
    });
}</code></pre>
      <p>
        There are several things to note here about the extension API. First, is the reference to pratphall.ts. This is just a directory above where this extension is. However, in your project where you may reference Pratphall locally in your package.json, it might be at node_modules/pratphall/src/pratphall.ts. Note, at the present extensions cannot reference other arbitrary TypeScript, it should all be self contained in the extension file.
      </p>
      <p>
        Next, this extension happens to be in the Pratphall module, but yours can be in any. The PhpEmitter class has a static method called register extension that takes a single object. This object must have a name, a description, a matcher object, and an emit function. The name and description are unused currently, but provide metadata about the extension.
      </p>
      <p>
        The matcher is an object that matches AST so the emitter knows when to invoke the extension. The nodeType property is an array of node types this extension accepts. You will have to reference the TypeScript source code to see what these node types are. The priority property is a numeric value which defines the order in which the extension is executed. The higher the priority, the earlier it will be executed. All Pratphall extensions use a priority of 1. Finally there is the propertyMatches property. This property is simply a collection of functions bound to names of properties on the AST object you are targeting. The function will be called with that property as the parameter and you must return true for it to be handled. In the above example, this checks that it is a dotted binary expression whose right hand side is to toString function (e.g. something.toString).
      </p>
      <p>
        The emit function accepts the AST and the PHP emitter as parameters. Again, you may have to look at the TypeScript and Pratphall source to understand these. The emitter offers several functions to help emit PHP. If the function returns true, no more extensions for this AST node will be executed. If it returns false, other extensions down the priority chain will be executed. If no extensions match an AST node, it is emitted normally.
      </p>
      <p>

      <span class="bookmark" id="Manual-Metaprogramming-Example"></span>
      <h4 class="para-link">Example <a href="#Manual-Metaprogramming-Example">&nbsp;&para;</a></h3>

      <p>
        Let's say you wanted to make an extension that ran some code that was output buffered and then flushed the buffer at the end. In PHP you do this with <code>ob_start</code> and <code>ob_end_flush</code>. On the Pratphall side, you will want to create a compile-time function to help with this. Then you can use it in Pratphall:
      </p>
      <pre><code data-language="javascript">//create a module with a declared (ambient) function
//NOTE: this could also be a class w/ a static function or anything
module Output {
    declare function bufferThenFlush(code: () => void);
}

//now use it
Output.bufferThenFlush(() => {
    //buffer this!
    echo('blah');
});</code></pre>
      <p>
        So now we must make an extension in TypeScript. Let's assume our extension is at src/myext.ts. Here is what it might look like:
      </p>
      <pre><code data-language="javascript">///&lt;reference path='../node_modules/pratphall/src/pratphall.ts' />

module MyExt {
    import TS = TypeScript;

    PhpEmitter.registerExtension({
        name: 'Buffer.outputThenFlush',
        description: 'Handle output-then-flush handler',
        matcher: {
            nodeType: [TS.NodeType.Call],
            priority: 5,
            propertyMatches: {
                target: (value: TS.AST) => {

                    //isDottedBinEx is a helper available to you to check a dotted binary expression
                    return isDottedBinEx(value, 'Buffer', 'outputThenFlush');
                }
            }
        },
        emit: (ast: TS.CallExpression, emitter: PhpEmitter): bool => {

            //first grab the argument
            var arg = ast.arguments.members[0];

            //let's make sure it's an anonymous function declaration
            if (!(arg instanceof TS.FuncDecl) || !(&lt;TS.FuncDecl>arg).isAnonymousFn()) {
                emitter.addError(arg, 'Argument must be an anonymous function');
                //return true saying we've handled this (will skip emit)
                return true;
            }

            //let's start the output buffering
            emitter.write('ob_start();').newline();

            //now we need to take the body of the function and emit it directly
            var func = &lt;FuncDecl>arg;
            //emitBlockStatements is a helper...otherwise, a normal emit() can be used for AST's
            //the true means we want newlines before each statement
            emitter.emitBlockStatements(func.bod, true);

            //now end and flush
            //notice we omit the ending semi-colon...that is because this was originally
            //  a statement and all statements receive a semi-colon already; so after this is
            //  written a semicolon and newline is automatically added just like if this extension
            //  was never executed
            emitter.newline().newline().write('ob_end_flush()');

            //return true to say we've handled it
            return true;
        }
    });
}</code></pre>
      <p>
        That's all there is to it. Now when running ppc, you can pass <code>--ext src/myext.ts</code> and the code that used the ambient function will look like this.
      </p>
      <pre><code data-language="javascript">ob_start();

//buffer this!
echo('blah');

ob_end_flush();</code></pre>
      <p>
        Extensions are also a good way to write validators. Simply do your checks and add errors or warnings in the emit function. You can return false on errors to skip emitting or true to continue. There are many examples of extensions in the Pratphall source at src/ext. Even <a href="http://github.com/cretz/dust-php">dust-php</a> uses an extension in the test/ folder that takes some JSON and makes test cases out of it. It is a complex subject, but working through a few will make it easier to understand.
      </p>

      <span class="bookmark" id="Manual-Faq"></span>
      <h3 class="para-link">FAQ <a href="#Manual-Faq">&nbsp;&para;</a></h3>

      <dl class="heading-list">
        <dt>This is neat, so I can convert my PHP programs to JavaScript/TypeScript? Can I convert my JavaScript/TypeScript programs to PHP?</dt>
        <dd>
          No and no (basically). The goal of this project is to provide a new language that emits PHP. Pratphall intentionally doesn't convert existing code because it would put too many constraints on the language's freedom and would require a significant runtime layer which is unacceptable.
        </dd>
        <dt>Well, can you generate the ambient declarations from existing PHP code with strong PHPDoc blocks? Or maybe generate PHPDoc annotations when emitting?</dt>
        <dd>
          In theory, ambient declarations could be generated from existing PHP code. Also, PHPDoc annotations could be generated during compilation. The problem is that PHPDoc and Pratphall's typing systems don't lineup very well. For example, PHPDoc doesn't support differentiating between numerically indexed arrays and associative arrays. And Pratphall doesn't support knowing whether a value is nullable or not (e.g. the <code>string|null</code> PHPDoc type).
        </dd>
        <dt>Ok, then can I at least write Pratphall code that can also run in a JavaScript environment?</dt>
        <dd>
          Technically, yes. Many features of JavaScript/TypeScript are supported. If you are careful and abstract properly, some of your Pratphall code can also run in a browser. For instance, imagine you had a bunch of model objects that are serialized to and from JSON for use in RESTful API calls. If you needed the server side to have these models for processing and the client side to have them for an AJAX call, you could share the Pratphall model code.
        </dd>
        <dt>How does this effort relate to <a href="http://phpjs.org">php.js</a>? Can I use it?</dt>
        <dd>
          Pratphall has not been tested with php.js in any way whatsoever, so use at your own risk. Though, in theory there are two ways Pratphall and php.js can work together. Firstly, if you were targeting both a JS environment and PHP, php.js has runtime support for many of the PHP functions you may need in both environments. Secondly, Pratphall supplies typed definitions for all PHP functions which means even if you're not developing in Pratphall and instead just developing in TypeScript, you now have a typed set of definitions for all the phpjs functions.
        </dd>
        <dt>You are almost there for supporting the entire language of JavaScript/TypeScript, why not support it 100%? Then you can bootstrap Pratphall in PHP too.</dt>
        <dd>
          This would require too much runtime support since certain features of JavaScript/TypeScript have no equivalent in PHP. It is possible that an ancillary fork of Pratphall may aim to support the entirety of JavaScript/TypeScript, but it will be as an extension because Pratphall's goal is to compile to readable, minimal, and predictable PHP.
        </dd>
        <dt>What is the minimum PHP version Pratphall supports?</dt>
        <dd>
          Currently, it is PHP 5.4. Several features (mainly short array syntax and closures w/ $this) are required. If you use <code>finally</code> in your try blocks, then PHP 5.5 is required. This decision was made since Pratphall is a new language and should not be bound by older environments. It is possible that 5.3 will be supported with a compiler option if there is enough need.
        </dd>
        <dt>I have heard that "transpiled" languages suffer from debugging issues. How do you debug code in Pratphall?</dt>
        <dd>
          Currently there is no easy method to debug Pratphall in your favorite editor. If the Visual Studio protocol was more public and friendly (i.e. not COM/DCOM) we could write a proxy to convert Xdebug events to Visual Studio events (if anyone can help here, we'd appreciate it). If node-inspector accepted source mapping (ref <a href="https://github.com/dannycoates/node-inspector/issues/100">issue 100</a>) we could possibly proxy the Xdebug events to V8 protocol. Or if <a href="http://jbaron.github.com/cats/">CATS</a> had integrated debugging w/ V8 protocol, we could do it there too (ref <a href="https://github.com/jbaron/cats/issues/6">issue 6</a>). Maybe the best idea is to combine the source map support in Chrome Canary and the remote debugger protocol and use Chrome's devtools as the client (maybe embedded via node-webkit). But for now, there is no direct debugging.
        </dd>
        <dt>How complete is this? Should I depend on it for production code?</dt>
        <dd>
          It is fairly complete, however TypeScript itself is still only in preview. They might implement new features or change existing ones which can affect Pratphall. Using for production code shouldn't be a problem since the language is cross-compiled and the PHP is easily readable and auditable. The only real problem comes from backwards incompatibilities from Pratphall being unstable. Pratphall's first stable release will not be before TypeScript's first stable release (and maybe well after, depending).
        </dd>
      </dl>

      <span class="bookmark" id="Manual-Appendices"></span>
      <h3 class="para-link">Appendices <a href="#Manual-Appendices">&nbsp;&para;</a></h3>

      <span class="bookmark" id="Manual-Appendices-VisualStudio"></span>
      <h4 class="para-link">Visual Studio Support <a href="#Manual-Appendices-VisualStudio">&nbsp;&para;</a></h4>
      <p>
        Until the next version of TypeScript is available, Visual Studio support for Pratphall is lacking. This is because the platform is too closed to alter the implicit library definitions to include the PHP runtime definitions. Having said that, it is still the most complete IDE for Pratphall. It is recommended to use --no-php-lib when compiling and adding a reference to php.d.ts (in the bin directory of installation) to a commonly referenced base. This will give intellisense support and all normal Visual Studio features.
      </p>
      <p>
        There are a few reported errors from the TypeScript compiler that Pratphall suppresses. These will appear as errors in Visual Studio, but are not Pratphall errors. They are:
        <ul>
          <li>
            When an interface is used in an instanceof expression, TypeScript emits an error. This is due to the fact that in TypeScript, all interfaces are compile-time only whereas in Pratphall most of them are runtime interfaces. There is currently no workaround for this.
          </li>
          <li>
            The super type for both PHP associative arrays and indexed arrays is the Array type. However, there is currently a bug in TypeScript preventing using this type to represent both, so for all PHP functions that use this super type in their parameters, Visual Studio will show an error for normal indexed arrays. TypeScript issue <a href="http://typescript.codeplex.com/workitem/331">TS-331</a> should fix this issue.
          </li>
          <li>
            In certain cases, Visual Studio says items are not visible that are. Currently the Pratphall compiler swallows these errors. TypeScript issue <a href="http://typescript.codeplex.com/workitem/245">TS-245</a> should fix this issue.
          </li>
          <li>
            Implementations of ArrayAccess will show an error in Visual Studio because it is currently impossible to overload indexes. TypeScript issue <a href="http://typescript.codeplex.com/workitem/577">TS-577</a> should fix this issue.
          </li>
        </ul>
      </p>
      <p>
        Despite the above, using Visual Studio is well worth it. Besides the refactoring and search capabilities, you also get intellisense:
      </p>
      <img src="intellisense.png" />

      <span class="bookmark" id="Manual-Appendices-Building"></span>
      <h4 class="para-link">Building From Source <a href="#Manual-Appendices-Building">&nbsp;&para;</a></h4>
      <p>
        Building from source is done very easily. You must have nodejs installed. Then, clone the <a href="https://github.com/cretz/pratphall.git">git repository</a>:
        <pre>git clone https://github.com/cretz/pratphall.git</pre>
        Run npm install to resolve the development dependencies:
        <pre>npm install</pre>
        This will install jake locally. Now run the build task with local Jake (or the global version if you already have Jake installed):
        <pre>node_modules/.bin/jake build</pre>
        This will compile everything into a single JS and move everything to the bin directory. You can also run the test cases very easily:
        <pre>node_modules/.bin/jake test</pre>
      </p>

      <span class="bookmark" id="Manual-Appendices-Configuration"></span>
      <h4 class="para-link">Configuration Files <a href="#Manual-Appendices-Configuration">&nbsp;&para;</a></h4>
      <p>
        A configuration file can be passed in to ppc using the <code>-c</code> or <code>--config</code> option. It contains all the same features as the command line options, but sometimes worded differently. When a configuration file is specified, it overwrites any command line parameters that may appear before it. If there are command line parameters after the configuration file parameter, they will override command line options. Here is the TypeScript class definition (with defaults) the JSON values are merged into:
      </p>
      <pre><code data-language="javascript">class CompilerOptions {
    //whether or not to emit comments on output
    comments = true;

    //whether or not to exclude emitting files above/outside
    //of the input file's directory
    excludeOutside = false;

    //array of extension .ts files to be loaded
    extensions: string[] = [];

    //if true, makes all single line if, while, etc
    //statements have a block for their contents
    forceBlock = false;

    //if true, forces the opening brace of any function
    //(non closure) declaration to start on the next line
    // by itself
    functionBraceNewline = false;

    //the number of times to indent per depth, usually best at 1
    //if indentSpaces is false (meaning using tabs)
    indentCount = 4;

    //if true, indent with spaces; if false, indent with tabs
    indentSpaces = true;

    //whether or not to include TypeScript's lib.d.ts
    jsLib = true;

    //if true, parse/compile only, do not emit output files
    lint = false;

    //if true, organize source into PSR-0-style type-per-file
    organize = true;

    //the individual file or directory to output to
    out: string = null;

    //whether or not to include the php.d.ts runtime lib automatically
    phpLib = true;

    //if true, will always use single quotes unless there is
    //an escape character
    preferSingleQuotes = false;

    //if true, Pratphall reference's will become require_once statements
    requireReferences = false;

    //if true, emits a single PHP file with all source
    single = false;

    //if true, forces the opening brace of any class or interface
    //declaration to start on the next line by itself
    typeBraceNewline = false;

    //if false, do not emit type hints on any functions in the output
    typeHint = true;

    //if false, use "else if" instead of "elseif"
    useElseif = true;

    //if true, output lots of extra information during compile
    verbose = false;

    //if true, run as daemon, watching for changes on any referenced
    //files and triggering a smart recompile
    watch = false;

    //the number of milliseconds after the last file change event
    //to start the smart recompile
    watchDebounceMs = 1500;
}</code></pre>
      <p>
        Here is an example of a configuration that complies mostly with <a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md">PSR-2</a>:
      </p>
      <pre><code data-language="javascript">{
    "forceBlock": true,
    "functionBraceNewline": true,
    "indentCount": 4,
    "indentSpaces": true,
    "organize": true,
    "typeBraceNewline": true,
    "useElseif": true
}</pre></code>

      <span class="bookmark" id="Manual-Appendices-Gotchas"></span>
      <h4 class="para-link">Gotchas <a href="#Manual-Appendices-Gotchas">&nbsp;&para;</a></h4>
      <p>
        Below are gotchas that might not be expected during development
      </p>
      <dl class="heading-list">
        <dt><code>001: Pratphall can't tell whether it's invoking an object's method or object's property that's a closure</code></dt>
        <dd>
          Unfortunately if you have an object property that's a closure in PHP, you cannot invoke it like <code>$obj->property();</code>, you have to do something like <code>$obj->property->__invoke();</code>. Sometimes there isn't enough typing information to determine whether a method invocation is a closure on a property or a method on an object. Therefore, Pratphall has to emit something like <code>(method_exists($obj, 'property') ? $obj->property() : $obj->property->__invoke());</code>. In order to avoid this, make sure your types are strong so the engine can tell which is which.
        </dd>
        <dt><code>002: Pratphall doesn't support naming properties/variables and methods/functions the same, making declarations for external PHP w/ name ambiguities difficult</code></dt>
        <dd>
          Any time you want name ambiguity in your PHP code, simply use an extra underscore at the end of either identifier in Pratphall. Any identifier that doesn't start with an underscore, but ends with one will have the ending underscore removed in translation.
        </dd>
        <dt><code>003: the JS arguments variable that gets the function arguments is unavailable if redefined later in function</code></dt>
        <dd>
          Basically, if you use the arguments array, then create a var later in the same function named arguments, we cannot tell the one used above the re-declaration needs func_get_args. Basic rule of thumb is not to use the arguments array in a function unless you have to, and then don't redefine it in the function.
        </dd>
        <dt><code>004: String.charCodeAt only uses ord when emitting</code></dt>
        <dd>
          Even though <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/charCodeAt">String.charCodeAt</a> supports unicode in JS, we only use <a href="http://php.net/manual/en/function.ord.php">ord</a>. Please handle unicode needs separately.
        </dd>
        <dt><code>005: String.indexOf emits more than just strpos.</code></dt>
        <dd>Due to the fact the JS one returns -1, the emitter emulates that. To avoid this, just call strpos directly.</dd>
        <dt><code>006: Regular expressions are flat out unsupported</code></dt>
        <dd>JS and PHP's regular expression syntaxes differ too much to support right now</dd>
        <dt><code>007: String.replace doesn't support callback</code></dt>
        <dd>There is no str_replace_callback in PHP, only a regex version</dd>
        <dt><code>008: String.slice and String.substring are unsupported</code></dt>
        <dd>
          Although negatives work the same for end and length in slice and substr, there is not an easy way to determine negative. Same issue with converting from end to length. It would require too much runtime support on the PHP side.
        </dd>
        <dt><code>009: String.toLocaleLowerCase and toLocaleUpperCase are unsupported</code></dt>
        <dd>There is no guarantee that mb_ functions are available</dd>
        <dt><code>010: Object.valueOf is unsupported</code></dt>
        <dd>No equivalent in PHP</dd>
        <dt><code>011: Many Object functions (e.g. freeze) are unsupported</code></dt>
        <dd>No equivalents in PHP, but no errors emitted because they can be overridden</dd>
        <dt><code>012: Array.reverse is unsupported</code></dt>
        <dd>No equivalent in PHP that alters the array instance</dd>
        <dt><code>013: Array iteration functions don't really support second parameter "this"</code></dt>
        <dd>
          The only value allowed as a second parameter in an array iteration function is literal "this".
        </dd>
        <dt><code>014: Array.every is unsupported</code></dt>
        <dd>No PHP equivalent</dd>
        <dt><code>015: Array.indexOf is unsupported</code></dt>
        <dd>
          array_search can't support fromIndex, would have to be strict, and would require too much runtime support to make false return -1.
        </dd>
        <dt><code>016: Array.join assumes comma by default</code></dt>
        <dd>
          A comma is used as the glue for implode if not specified.
        </dd>
        <dt><code>017: Array.lastIndexOf is unsupported</code></dt>
        <dd>No PHP equivalent</dd>
        <dt><code>018: Array.reduceRight is unsupported</code></dt>
        <dd>No PHP equivalent</dd>
        <dt><code>019: Second parameter of Array.slice is unsupported</code></dt>
        <dd>No PHP equivalent</dd>
        <dt><code>020: Array.some is unsupported</code></dt>
        <dd>No PHP equivalent</dd>
        <dt><code>021: Second parameter of JSON.parse is unsupported</code></dt>
        <dd>No PHP equivalent</dd>
        <dt><code>022: Second and third parameters of JSON.stringify are unsupported</code></dt>
        <dd>No PHP equivalent</dd>
        <dt><code>023: Class/interface names cannot be the same as module/namespace names at the same level</code></dt>
        <dd>
          This is common practice in PHP especially before namespaces were introduced. We believe this lack of support will actually help properly group types instead of using namespaces as OOP extension paths. Any time you want name ambiguity in the PHP code, an underscore can be added to the end of any identifier and (assuming the identifier doesn't start with an underscore), it will be removed.
      </dl>

      <span class="bookmark" id="Manual-Appendices-Future"></span>
      <h4 class="para-link">Future <a href="#Manual-Appendices-Future">&nbsp;&para;</a></h4>
      <p>
        These are some wishlist items that could be implemented in the future.
        <ul>
          <li>
            Emit exact PHPDoc based on the <a href="https://github.com/phpDocumentor/phpDocumentor2/blob/master/docs/PSR.md">PSR</a>.
          </li>
          <li>
            Optionally emit runtime type checks at the beginning of functions and/or results from functions.
          </li>
          <li>
            Support generators.
          </li>
          <li>
            Create a proxy to proxy Xdebug protocol to other debugging protocols used in common IDE's.
          </li>
          <li>
            A macro syntax that is inline.
          </li>
          <li>
            Now that it appears property accessors <a href="https://wiki.php.net/rfc/propertygetsetsyntax-v1.2#voting">will be accepted</a>, support the TypeScript property accessor syntax and think about how best to support isset and unset.
          </li>
          <li>
            Expose extensibility in the type checking system.
          </li>
          <li>
            Support open classes/interfaces.
          </li>
          <li>
            Add online playground. Should be very easy since it's all simple JavaScript. Could even leverage phpfiddle's API and the GitHub gist framework to execute the compiled code, save it for later use, etc.
          </li>
          <li>
            Get up and running on Travis CI.
          </li>
          <li>
            Optionally auto-use all needed references outside of the current namespace.
          </li>
          <li>
            Generics! They are coming...
          </li>
        </ul>
        These are some items that need to be fixed.
        <ul>
          <li>Need to stream output and stop using so much RAM</li>
          <li>
            In Pratphall, type-hinted parameters w/out default null can still accept null. This needs to be a compiler error since PHP does not support it.
          </li>
          <li>
            Return inside forEach closure needs to become a continue. Also need a break construct.
          </li>
        </ul>
      </p>

      <span class="bookmark" id="Manual-Appendices-Changelog"></span>
      <h4 class="para-link">Changelog <a href="#Manual-Appendices-Changelog">&nbsp;&para;</a></h4>
      <p>
        <dl>
          <dt>0.1.0</dt>
          <dd>
            Initial release
          </dd>
        </dl>
      </p>

    </div>
    <script src="jquery.min.js"></script>
    <script src="bootstrap.min.js"></script>
    <script src="rainbow-custom.min.js"></script>
    <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37431760-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

    </script>
  </body>
</html>