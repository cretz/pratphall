<!DOCTYPE html>
<html>
  <head lang="en">
    <title>Pratphall</title>
    <link href="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/css/bootstrap-combined.min.css" rel="stylesheet">
    <link href="pratphall.css" rel="stylesheet">
  </head>
  <body>
    <div class="topbar">
      <h1 class="topbar-title">
        <a class="title" href="#Top">Pratphall</a>
        <small> - A typed language targeting <a href="http://php.net">PHP</a>*</small>
      </h1>
      <div style="text-align: right; position: relative; float: right; margin-top: 0px; right: 10px;">
        <p class="muted">*Actually, it's just <a href="http://typescriptlang.org">TypeScript</a> cross-compiled.</p>
        <a class="btn btn-link dropdown-toggle" data-toggle="dropdown" href="#" style="padding: 0px">
          Doc <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li class="dropdown-title">Getting Started</li>
          <li><a tabindex="-1" href="#GettingStarted-Installation">Installation</a></li>
          <li><a tabindex="-1" href="#GettingStarted-Compiling">Compiling</a></li>
          <li class="dropdown-title">Manual</li>
          <li><a tabindex="-1" href="#Manual-Introduction">Introduction</a></li>
          <li><a tabindex="-1" href="#Manual-Usage">Usage</a></li>
          <li><a tabindex="-1" href="#Manual-Types">Types</a></li>
          <li><a tabindex="-1" href="#Manual-Syntax">Syntax</a></li>
          <li><a tabindex="-1" href="#Manual-Structure">Structure</a></li>
          <li><a tabindex="-1" href="#Manual-Metaprogramming">Metaprogramming</a></li>
          <li><a tabindex="-1" href="#Manual-Appendices">Appendices</a></li>
        </ul> |
        <a href="https://github.com/cretz/pratphall">GitHub</a> |
        <a href="https://groups.google.com/d/forum/pratphall">Mailing List</a>
      </div>
    </div>
    <div class="container">
      <span class="bookmark" id="Top"></span>
      <div style="margin-top: 80px">
        <div style="float: left; width: 100px">&nbsp;</div>
        <div style="float: left; width: 300px">
          <h3>Features</h3>
          <ul>
            <li>Optional typing</li>
            <li>Readable PHP output</li>
            <li>IDE support</li>
            <li>Metaprogramming facilities</li>
            <li>PHP interoperability</li>
            <li>Apache 2 licensed</li>
          </ul>
        </div>
        <div style="float: left; width: 400px">
          <h3>Anti-Features</h3>
          <ul>
            <li>Not fixing PHP standard library</li>
            <li>Not emitting obtuse/complicated PHP code</li>
            <li>Not auto-generating Pratphall from PHP code</li>
            <li>Not adding any code in TypeScript core</li>
            <li>Not supporting every PHP feature</li>
            <li>Not supporting every JS/TypeScript feature</li>
          </ul>
        </div>
        <br class="clearfix" style="clear: left;" />
      </div>
      <h1 style="color: red">Placeholder page...not ready yet!!!</h1>
      <h3>Overview</h3>
      <p>
        Pratphall is an optionally-typed language that compiles to readable PHP. PHP has a powerful engine and is very scalable since state is primarily per-request for PHP scripts. Unfortunately, due to the dynamic nature of PHP, it can be difficult to build large projects and retain the ability to refactor and manage the code. It can also be difficult to foresee errors with typing and unavailable variables. Almost all of these issues cause many problems that don't surface until runtime. Pratphall aims to solve this.
      </p>
      <p>
        Pratphall started as kind of a joke (hence the name) and proof of concept to see if <a href="http://typescriptlang.org">TypeScript</a> could be reliably translated. It turns out it can. So Pratphall is for all practical purposes just TypeScript (which is a typed superset of JavaScript) cross-compiled. And although not every single JS idiom directly translates, remembering that <strong>Pratphall is just TypeScript which is just typed JavaScript</strong> will help development greatly.
      </p>
      <h3>Example</h3>
      Here is an example of Pratphall compiling to PHP
      <div class="code">
        <pre><code class="pratphall">//normal array
var arr = [1, 2, 3, 4, 5];

//loop and print
arr.forEach((value: number) => {
    echo('My value: ' + value + '\n');
});

//compile-time-only class
class SampleContract implements Pct.CompileTimeOnly {
    requiredProperty: string;
    optionalProperty?: bool;
}

//function using compile-time class
printInfo(info: SampleContract) => {
    echo('Required: ' + info.requiredProperty + '\n');
    if (typeof info.optionalProperty !== 'undefined') {
        echo('Optional: ' + info.optionalProperty + '\n');
    }
}

//type inferred matching
printInfo({ requiredProperty: 'required val' });</code></pre>
        <pre><code class="php">//normal array
$arr = [1, 2, 3, 4, 5];

//loop and print
foreach ($arr as $value) {
    echo('My value: ' . $value . "\n");
}



/*Spacing added in example for clarity*/



//function using compile-time interface
function printInfo($info) {
    echo('Required: ' . $info->requiredProperty . "\n");
    if (array_key_exists('optionalProperty', $info)) {
        echo('Optional: ' . $info->optionalProperty . "\n");
    }
}

//type-inferred matching
printInfo((object)[ 'requiredProperty' => 'required val' ]);</code></pre>
      </div>

      <h2>Getting Started</h2>

      <span class="bookmark" id="GettingStarted-Installation"></span>
      <h5>Installation</h5>
      <p>To use Pratphall from the command line, simply install via NPM:</p>
      <pre>npm install -g pratphall</pre>
      <p>
        You may also want to install <a href="http://www.microsoft.com/en-us/download/details.aspx?id=34790">TypeScript for Visual Studio 2012</a> if you want to use Visual Studio as your editor. For more information about Visual Studio support, see <a href="#Appendix-VisualStudioSupport">below</a>.
      </p>
      <p>If you want to build Pratphall from source, see the <a href="#Appendix-BuildingFromSource">Building From Source</a> appendix.</p>

      <span class="bookmark" id="GettingStarted-Compiling"></span>
      <h5>Compiling</h5>
      <p>Write the following simple script and save it as sayHello.ts:</p>
      <pre><code class="pratphall">function sayHello(subject: string) {
    return 'Hello, ' + subject;
}

var theSubject = 'World';

echo(sayHello(theSubject) + '\n');</code></pre>
      <p>Now, to compile to PHP, run ppc like so:</p>
      <pre>ppc sayHello.ts</pre>
      <p>This will create a sayHello.php file that looks like this:</p>
      <pre><code class="php">function sayHello($subject) {
    return 'Hello, ' . $subject;
}

$theSubject = 'World';

echo(sayHello(theSubject) . "\n");</code></pre>
      <p>Running this with PHP will output what you expect. However, if you tried to compile this:</p>
      <pre><code class="pratphall">function sayHello(subject: string) {
    return 'Hello, ' + subject;
}

var theSubject = 123;

echo(sayHello(theSubject) + '\n');</code></pre>
      <p>
        You would get: <code>sayHello.ts(7,5): Supplied parameters do not match any signature of call target</code>. This is because you are attempting to pass a number to a function that only accepts strings.
      </p>

      <h2>Manual</h2>

      <span class="bookmark" id="Manual-Introduction"></span>
      <h3 id="Manual-Introduction">Introduction</h3>

      <h4>Who?</h4>
      <p>
        Nobody really. It's a project that was started in <a href="http://github.com/cretz">my</a> spare time and only maintained in my <em>spare</em> time. There is no commercial support, no guarantee that anything will get fixed, and no guarantee that the project will be properly maintained. I am not aware of any use in a production environment, so use at your own risk. If it becomes popular, it is possible it could become a more professional language. Feel free to discuss the language or ask questions on the <a href="https://groups.google.com/d/forum/pratphall">mailing list</a>.
      </p>

      <h4>What?</h4>
      <p>
        Pratphall is <a href="http://typescriptlang.org">TypeScript</a> compiled to PHP. It includes several helpers to make this easier. Pratphall is licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2</a> license.
      </p>

      <h4>Where?</h4>
      <p>
        The source is on <a href="https://github.com/cretz/pratphall">GitHub</a> and the site is on <a href="https://github.com/cretz/pratphall/tree/gh-pages">GitHub</a>. Follow development, fork, send pull requests, and submit issues there.
      </p>

      <h4>When?</h4>
      <p>
        I don't know. It's in an almost alpha state until it gets more traction.
      </p>

      <h4>Why?</h4>
      <p>
        This is basically for static typing enthusiasts that use PHP either because they are forced to or like the PHP engine and scalability. Using PHPDoc annotations is rarely a good enough solution and editor support for them is limited. After noticing extreme parity between TypeScript and PHP, a simple tool was built to do the cross-compiling. This is the result.
      </p>
      <p>
        Pratphall can be used to make a really scalable codebase in PHP. It can also reduce the verbosity (e.g. several classes/modules in one file) and increase productivity through editor support (e.g. Visual Studio with IntelliSense). Refactoring and determining use throughout the your codebase will now be really easy. And, if the abstraction is written properly, code can even be shared between JS/PHP. At the very least this really helps when defining typed model classes.
      </p>

      <h4>How?</h4>
      <p>
        Pratphall simply leverages the TypeScript compiler and type checker. Because TypeScript is written so well, it is very easy to change the language it emits to. In this case, a new emitter was written to just write PHP instead of JavaScript.
      </p>

      <span class="bookmark" id="Manual-Usage"></span>
      <h3>Usage</h3>
      <pre>ppc [options] FILE...</pre>
      <p>Options:</p>
      <dl class="dl-horizontal">
        <dt><code>--all-caps-consts</code></dt>
        <dd>When set and any variable is all capital letters, it will assume it's a constant and not prefix it with a dollar sign in PHP</dd>
        <dt><code>--ext FILE</code></dt>
        <dd>Can be used as many times as necessary to include extensions<dd>
        <dt><code>--no-comments</code></dt>
        <dd>Do not emit comments</dd>
        <dt><code>--no-composer</code></dt>
        <dd>Do not emit the composer autoloader require statement</dd>
        <dt><code>--no-js-lib</code></dt>
        <dd>Do not automatically include the lib.d.ts JS definitions</dd>
        <dt><code>--no-organize</code></dt>
        <dd>When set, this will not organize source files into the <a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md">PSR-0</a> autoloader-acceptable filesystem structure</dd>
        <dt><code>--no-php-lib</code></dt>
        <dd>Exclude the runtime/all.ts PHP definitions and exclude the ext/all.ts PHP extensions</dd>
        <dt><code>--no-type-hint</code></dt>
        <dd>Do not type hint emitted functions in any way</dd>
        <dt><code>-o, --out PATH</code></dt>
        <dd>When <code>--single</code> is present or there is only a single file on the command line, this is the single file to output to. References in the file are emitted relative to this single file path when not using <code>--single</code>. Otherwise, this is the directory to put all files at relative to the files given.</dd>
        <dt><code>--prefer-single-quotes</code></dt>
        <dd>When set, this will try to use single quotes for all strings that don't have escape characters</dd>
        <dt><code>--require-references</code></dt>
        <dd>When set, all <code>///&lt;reference /></code> will become <code>require_once</code>. This is only allowed when <code>--no-organize</code> is set.</dd>
        <dt><code>--single</code></dt>
        <dd>Compile all files to a single PHP file. This is basically also setting <code>--no-organize</code> also, so both cannot be present.</dd>
        <dt><code>--use-elseif</code></dt>
        <dd>When an "else if" is encountered in Pratphall, translate to "elseif" instead of the default "else if"</dd>
      </dl>

      <span class="bookmark" id="Manual-Types"></span>
      <h3>Types</h3>

      <h4>Booleans</h4>
      <p>Booleans and conversions happen the same way in Pratphall as they do in PHP.</p>

      <h4>Strings</h4>
      <p>
        Strings in Pratphall and PHP are very similar. There are no multiline strings. There is no string interpolation (attempts are escaped). Usually, the preference of single quote or double quote in the Pratphall script is translated verbatim to PHP. However, if there is an escape character in a single-quoted string, it will become double quoted. To request that all strings without escape characters to become single quoted in PHP, use the <code>--prefer-single-quotes</code> compiler option.
      </p>
      <p>
        In Pratphall strings are concatenated with a plus sign. In PHP the dot operator is used. Type inference is used to determine when this translation should occur. In Pratphall, if either side of the plus operator is a string, concatenation is assumed. If either side of a plus operator is an unknown/any type a normal arithmetic plus will be used and a compiler warning will be issued.
      </p>
      <p>Normal JavaScript string functions are translated to common PHP idioms.</p>
      <div class="code">
        <pre><code class="pratphall">//will be converted to double quotes
var a = 'My\nNewline\nString$escaped{$interpolation}';

//concatenation
var b = 99 + ' bottles of beer on the wall';

//compiler warning because type is any
var c: any = 'test string';
var d = 12 + c;

//common JS functions
var_dump(b.length);
var_dump(b.charAt(0));
var_dump(b.split(' '));</code></pre>
        <pre><code class="php">//will be converted to double quotes
$a = "My\nNewline\nString\$escaped{\$interpolation}";

//concatenation
$b = 99 . ' bottles of beer on the wall';

//compiler warning because type is any
$c = 'test string';
$d = 12 + $c;

//common JS functions
var_dump(strlen($b));
var_dump($b[0]);
var_dump(explode(' ', $b));</code></pre>
      </div>

      <h4>Integers/Floats</h4>
      <p>
        In JS there is no difference between an integer and a float for the most part, and the same is true in Pratphall. Conversion and testing can still occur at runtime with intval, floatval, and other methods. At compile time however, they are simply numbers. There is no normal way to constrain a variable on one type or the other. Hexadecimal and octal literals are translated to normal decimal integers during translation.
      </p>

      <h4>Arrays</h4>
      <p>
        Unlike PHP, Pratphall differentiates between associative arrays and normal indexed arrays. The former is of type <code>Pct.PhpAssocArray</code> whereas the latter is a normal JS array. This can be confusing at first, but in practice it helps the developer make more accurate assumptions about the typing of variables. You can convert between these types at compile time using <code>Pct.toAssocArray</code> or <code>Pct.toArray</code>. Note when using the latter, (until TypeScript has generics) the result is <code>any[]</code> so it is recommended to cast it to the exact form of array expected.
      </p>
      <p>
        Associative arrays can be created with <code>Pct.newAssocArray</code>. Only object literals can be passed to the function. Indexed arrays are handled almost exactly like they are in JS. They are created with the normal bracketed syntax.
      </p>
      <p>Normal JavaScript array functions are translated to common PHP idioms.</p>
      <div class="code">
        <pre><code class="pratphall">//regular array
var a = [1, 2, 3];

//some calls
a.forEach((value: number) {
    var_dump(value);
});
a.push(4);

//associative array
var b = Pct.newAssocArray({
    prop: 'propValue',
    prop2: ['a', 'b', 'c'],
    closure: function () { echo('Hey!\n'); }
});

//some calls
var c = b.map((value: any) => {
    return gettype(value);
});
c['prop3'] = 15;
var_dump(c.length);</code></pre>
        <pre><code class="php">//regular array
$a = [1, 2, 3];

//some calls
foreach ($a as $value) {
    var_dump($value);
}
$a[] = 4;

//associative array
$b = [
    'prop' => 'propValue',
    'prop2' => ['a', 'b', 'c'],
    'closure' => function () { echo("Hey!\n"); }
];

//some calls
$c = array_map(function ($value) {
    return gettype($value);
}, $b);
$c['prop3'] = 15;
var_dump(count($c));</code></pre>
      </div>

      <h4>Objects</h4>
      <p>
        Objects in Pratphall and PHP work very similarly. Anonymous object literals become an stdClass via cast. Note, if you have a closure as an object property, it cannot necessarily be invoked like a method in PHP, so Pratphall has to do special handling (see <a href="#Appendix-Gotchas-001">GOTCHA-001</a>). TypeScript property accessors are not currently supported.
      </p>
      <div class="code">
        <pre><code class="pratphall">var obj = {
    num: 12,
    arr: ['a', 'b', 'c'],
    obj: { innerNum: 12 },
    func: (value: string) => { echo('Value: ' + value); }
};</code></pre>
        <pre><code class="php">$obj = (object)[
    'num' => 12,
    'arr' => ['a', 'b', 'c'],
    'obj' => (object)[ 'innerNum' => 12 ],
    'func' => function ($value) { echo('Value: ' . $value); }
];</code></pre>
      </div>

      <h4>Resources</h4>
      <p>PHP resources are represented by the <code>Pct.PhpResource</code> type in Pratphall.</p>

      <h4>Null and Undefined</h4>
      <p>Null is handled the same way in Pratphall and PHP.</p>
      <p>
        Undefined is different. In Pratphall, <code>delete</code> translates directly to <code>unset</code>. Conditions that check typeof <code>undefined</code> are translated to safe PHP that avoids false positives with NULL values unlike isset.
      </p>
      <p>
        Functions isset and empty are used like any other PHP function in Pratphall. Since these are language constructs, the values don't necessarily have to exist like they do in JS.
      </p>
      <div class="code">
        <pre><code class="pratphall">//normal null
var a = { prop1: null };
echo('a.prop1 null? ' + (a.prop1 == null));

//undefined
delete a.prop1;
echo('a.prop1 set? ' + (typeof a.prop1 == 'undefined'));</code></pre>
        <pre><code class="php">//normal null
$a = (object)[ 'prop1' => null ];
echo('a.prop1 null? ' . ($a->prop1 == null));

//undefined
unset($a->prop1);
echo('a.prop1 set? ' . (!array_key_exists('prop1', $a)));</code></pre>
      </div>

      <h4>Callbacks</h4>
      <p>
        Pratphall supports full typed closure type definitions instead of just the callable type hint in PHP. Even methods of objects can be passed around like normal.
      </p>
      <div class="code">
        <pre><code class="pratphall">class Foo {
    bar(value: string) { echo('Value: ' + value); }
}

var foo = new Foo();
var f = foo.bar;
//call
f('test');</code></pre>
        <pre><code class="php">class Foo {
    public function bar($value) { echo('Value: ' . $value); }
}

$foo = new Foo();
$f = (new ReflectionMethod('Foo', 'bar'))->getClosure($foo);
//call
$f('test');</code></pre>
      </div>
      <p>
        This is safe since unlike PHP, Pratphall does not support naming properties/variables and methods/functions the same name. See <a href="#Appendix-Gotchas-002">GOTCHA-002</a> about interoperating with existing PHP that does
      </p>

      <h4>Pseudo-types</h4>
      <p>
        Void can be used for return types of functions. There is no such thing as <code>mixed</code>, but there is <code>any</code> which loosely translates. The use of the <code>any</code> type should be avoided when possible. If using <code>any</code>, you are encouraged to cast to a known type as soon as you can.
      </p>

      <h4>Casting</h4>
      <p>
        To cast to a value at compile time, use the TypeScript method. For example: <code>&lt;bool>&lt;any>stringValue</code> casts a string to a bool but will not be casted in the emitted PHP code. This is helpful for functions that return a value or FALSE. In fact, this is such a common pattern that there are compile-time helpers for it: <code>Pct.isFalse</code> and <code>Pct.isNotFalse</code>.
      </p>
      <p>
        To cast a value at runtime, it is always preferred to use the built-in PHP methods such as `strval`, `intval`, etc. If you must have a literal cast, you can use the `Pct.cast*` functions.
      </p>
      <div class="code">
        <pre><code class="pratphall">function printNumber(value: number) {
    echo('Number: ' + value + '\n');
}

//compile-time cast only
printNumber(&lt;number>&lt;any>'10');

//runtime PHP function cast
printNumber(intval('10'));

//runtime PHP explicit cast
printNumber(Pct.castInt('10'));

//two ways to check a FALSE return
if (&lt;bool>&lt;any>strpos('team', 'I') === false) {
    echo('There is no "I" in "team"\n');
}
if (Pct.isFalse(strpos('team', 'I'))) {
    echo('There is no "I" in "team"\n');
}</code></pre>
        <pre><code class="php">function printNumber($value) {
    echo('Number: ' . $value . "\n");
}

//compile-time cast only
printNumber('10');

//runtime PHP function cast
printNumber(intval('10'));

//runtime PHP explicit cast
printNumber(((int) '10'));

//two ways to check a FALSE return
if (strpos('team', 'I') === false) {
    echo("There is no \"I\" in \"team\"\n");
}
if (strpos('team', 'I') === false) {
    echo("There is no \"I\" in \"team\"\n");
}</code></pre>
      </div>

      <span class="bookmark" id="Manual-Syntax"></span>
      <h3>Syntax</h3>

      <h4>Variables</h4>
      <p>Variables names are case sensitive and are NOT prefixed with dollar signs (except for references, see later).</p>
      <p>
        All variables in Pratphall are defined somewhere. If they are declared globally and are used in a function, the <code>global</code> keyword is applied in the translated PHP. There is no Pratphall equivalent to the static variable in PHP (not to be confused with the static property/function of a class).
      </p>
      <div class="code">
        <pre><code class="pratphall">var a = 'myGlobalString';

function printGlobalString() {
    /*blank space here for clarity*/
    echo('Global string: ' + a);
}</code></pre>
        <pre><code class="php">$a = 'myGlobalString';

function printGlobalString() {
    global $a;
    echo('Global string: ' + $a);
}</code></pre>
      </div>
      <p>
        "Variable variables" are not supported in Pratphall in any way. The best you can do is access an object's property by its string-based name using the bracket syntax.
      </p>
      <div class="code">
        <pre><code class="pratphall">var obj = { child: { grandchild: 5 }};
echo('Grandchild val: ' + obj.child['grand' + 'child']);</code></pre>
        <pre><code class="php">$obj = (object)[ 'child' => (object)[ 'grandchild' => 5 ]];
echo('Grandchild val: ' . $obj->child->{'grand' . 'child'});</code></pre>
      </div>

      <h4>Constants</h4>
      <p>
        Constants cannot be defined in Pratphall by default. The closest you can get is creating a top-level var. Some existing libraries have constants though that need to be accessed when interoperating. You can avoid the dollar sign that is normally prefixed to PHP variables by using <code>Pct.const</code> to reference the constant.
      </p>
      <p>
        If the <code>--all-caps-consts</code> compiler option is set, all variables that are in all capital letters will be considered constants when both defining and accessing. Note, a compiler warning will be issued for attempted const declarations that are not literal scalar values.
      </p>
      <p>
        All magic constants are supported in the Pratphall compile-time library. <code>Pct.__LINE__</code> is a number, and all other magic constants are strings.
      </p>

      <h4>Operators</h4>
      <p>
        All operators work the same in Pratphall and PHP with the following exceptions:
        <dl>
          <dt><code>clone</code></dt>
          <dd>
            The Pratphall language has no keyword for clone. You can get the same effect by using <code>Pct.clone</code>
            <div class="code-nested">
              <pre><code class="pratphall">var obj = { foo: 'bar' };
var copy = Pct.clone(obj);</code></pre>
              <pre><code class="php">$obj = (object)[ 'foo' => 'bar' ];
$copy = clone $obj;</code></pre>
            </div>
          </dd>
          <dt><code>.</code></dt>
          <dd>
            String concatenation is done via <code>+</code> and translated based on type inference. Same goes for <code>.=</code> in PHP which is <code>+=</code> in Pratphall.
          </dd>
          <dt><code>and</code>, <code>xor</code>, <code>or</code></dt>
          <dd>Completely unsupported in Pratphall (not to be confused with support for <code>&amp;&amp;</code> and <code>||</code>).</dd>
          <dt><code>&gt;&gt;&gt;</code></dt>
          <dd>PHP does not have a zero-fill right shift, so the presence of this operator in Pratphall will cause a compiler error</dd>
          <dt><code>?:</code></dt>
          <dd>Pratphall supports the normal PHP ternary, but does not support the shorthand form which uses the conditional as the first result.</dd>
          <dt><code>&amp;</code></dt>
          <dd>References types and reference assignment are handled differently in Pratphall. See the References section.</dd>
          <dt><code>&lt;&gt;</code></dt>
          <dd>This is considered "not equal" in PHP. Pratphall does not support it.</dd>
          <dt><code>@</code></dt>
          <dd>
            The <code>@</code> symbol may not be used to swallow errors in Pratphall. If you must swallow errors, use <code>Pct.swallowErrors</code> (unwieldy name on purpose) which will use the <code>@</code> sign.
            <div class="code-nested">
              <pre><code class="pratphall">var f = Pct.swallowErrors(file('not-here.txt'));</code></pre>
              <pre><code class="php">$f = @file('not-here.txt');</code></pre>
            </div>
          </dd>
          <dt><code>`</code></dt>
          <dd>Backticks are unsupported in Pratphall. Use shell_exec if you must.</dd>
          <dt><code>+</code></dt>
          <dd>
            Addition with numbers works normally. Unioning arrays, if you must, is done with <code>Pct.unionArray</code>. Note, this comes back with <code>any[]</code> if you are using an indexed array, so please cast immediately back to what you expect it to be.
            <div class="code-nested">
              <pre><code class="pratphall">var a = &lt;number[]>Pct.unionArray([1, 2, 3], [4, 5, 6, 7]);</code></pre>
              <pre><code class="php">$a = [1, 2, 3] + [4, 5, 6, 7];</code></pre>
            </div>
          </dd>
          <dt><code>==</code>, <code>!=</code>, <code>===</code></dt>
          <dd>
            These translate directly, but it's important to understand that TypeScript/JS and PHP don't treat array or object equality the same, so be careful when writing shareable code comparing arrays or objects.
          </dd>
          <dt><code>instanceof</code></dt>
          <dd>
            This check will work just fine in Pratphall when the right hand side is the literal name of a class. If the right hand side is a string, interface, or some other expression you must use <code>Pct.isInstance</code>. Of course, <code>is_a</code> may be also be used as part of the PHP standard library.
            <div class="code-nested">
              <pre><code class="pratphall">class Foo { }
var a = new Foo();
var b = Pct.isInstance(a, 'Foo');</code></pre>
              <pre><code class="php">class Foo { }
$a = new Foo();
$b = a instanceof 'Foo';</code></pre>
            </div>
          </dd>
          <dt><code>typeof</code></dt>
          <dd>
            This has no operator/construct equivalent in PHP, but it is automatically translated to gettype (except for as used for checks with undefined). Note, the results can differ between JS and PHP, so make sure you code to the PHP environment or abstract when writing shareable code.
          </dd>
        </dl>
      </p>

      <h4>Control Structures</h4>
      <p>
        All control structures work the same in Pratphall and PHP with the following exceptions:
        <dl>
          <dt><code>elseif</code></dt>
          <dd>
            Use <code>else if</code> in Pratphall which will translate to <code>else if</code> in PHP also. The <code>--use-elseif</code> compiler option can be used to emit <code>elseif</code> instead when <code>else if</code> is found.
          </dd>
          <dt>
            <code>if():</code>, <code>elseif:</code>, <code>else:</code>, <code>endif;</code>, <code>while:</code>, <code>endwhile;</code>, <code>for:</code>, <code>endfor;</code>, <code>foreach:</code>, <code>endforeach;</code>, <code>switch:</code>, <code>endswitch;</code>
          </dt>
          <dd>Unsupported in Pratphall</dd>
          <dt><code>for...in</code></dt>
          <dd>
            This JS concept isn't present in any way in PHP and isn't worth the significant runtime code to support accurately. If this is seen, a compiler warning is issued and it's translated to a foreach of <code>array_keys</code> of an array cast which is not the exact same thing. These loops are discouraged.
            <div class="code-nested">
              <pre><code class="pratphall">var a = { b: 1, c: 2 };
for (b in a) {
    echo('a[' + b + ']: ' + a[b] + '\n');
}</code></pre>
              <pre><code class="php">$a = (object)[ 'b' => 1, 'c' => 2 ];
foreach (array_keys($a) as $b) {
    echo('a[' . $b . ']: ' . $a->{$b} . "\n");
}</code></pre>
            </div>
          </dd>
          <dt><code>foreach</code></dt>
          <dd>
            This is represented in Pratphall by the <code>forEach</code> function that can be called on an iterable object or an array. If the function passed to <code>forEach</code> is an inline closure, it will be translated directly. Otherwise, it will be translated to an <code>array_walk</code> call.
            <div class="code-nested">
              <pre><code class="pratphall">var a = Pct.newAssocArray({ b: 1, c: 2 });

//regular
a.forEach((value: number, index: string) => {
    echo('a[' + index + ']: ' + value + '\n');
});

//callback
var d = (value: number, index: string) => {
    echo('a[' + index + ']: ' + value + '\n');
};
a.forEach(d);</code></pre>
              <pre><code class="php">$a = (object)[ 'b' => 1, 'c' => 2 ];

//regular
foreach ($a as $index => $value) {
    echo('a[' + $index + ']: ' + $value + "\n");
}

//callback
$d = function ($value, $index) {
    echo('a[' + $index + ']: ' + $value + "\n");
};
array_walk($a, $d);</code></pre>
            </div>
          </dd>
          <dt><code>break #</code>, <code>continue #</code></dt>
          <dd>
            In Pratphall, break and continue statements are optionally associated with labels instead of a number. Normal breaks and continues in Pratphall work as normal. When a label is defined though, the construct becomes a goto. There is no equivalent for PHP's numbered break and continue statements. For example, `outside: while (a) { while (b) { break outside; } }` translates to `outside: while ($a) { while ($b) { goto outside; } }`.
            <div class="code-nested">
              <pre><code class="pratphall">var counter = 0;
again:
var lines = file('file' + (++counter) + '.txt');
for (var i = 0; i &lt; lines.length; i++) {
  var words = lines[i].split(' ');
  for (var j = 0; j &lt; words.length; j++) {
      var word = words[j];
      if (word == 'end') break done;
      else if (word == 'nextfile') break again;
      else echo('Word: ' + word + '\n');
  }
}
done:
echo('Done!\n');</code></pre>
              <pre><code class="php">$counter = 0;
again:
$lines = file('file' + (++$counter) + '.txt');
for ($i = 0; $i &lt; count($lines); $i++) {
  $words = explode(' ', lines[$i]);
  for ($j = 0; $j &lt; count($words); $j++) {
      $word = $words[$j];
      if ($word == 'end') goto done;
      else if ($word == 'nextfile') goto again;
      else echo('Word: ' . $word . "\n");
  }
}
done:
echo("Done!\n");</code></pre>
            </div>
          </dd>
          <dt><code>declare</code></dt>
          <dd>
            Not a construct in Pratphall, but can be called using <code>Pct.declare</code>. If a function is the last parameter of the call, it considers code within to be in a declare block.
          </dd>
          <dt><code>return</code></dt>
          <dd>Return from methods/functions works normally. Global return statements are unsupported</dd>
          <dt><code>include</code>, <code>include_once</code>, <code>require</code>, <code>require_once</code></dt>
          <dd>
            These are normal functions, but do not affect type checking. In order to affect type-checking, you must use <code>///&lt;reference /></code> elements at the top of your file. If the <code>--require-references</code> compiler option is set, reference elements will become <code>require_once</code> calls.
          </dd>
          <dt><code>goto</code></dt>
          <dd>Unsupported in Pratphall</dd>
        </dl>
      </p>

      <h4>References</h4>
      <p>
        Pratphall recommends avoiding references. If you cannot, they are supported.
      </p>
      <p>
        To assign by reference or otherwise reference, use <code>Pct.byRef</code>.
      </p>
      <p>
        To pass by reference, the parameter in the function must start with a dollar sign. A compiler error occurs if the item passed by reference is not valid (e.g. expressions or literals).
      </p>
      <p>
        To return by reference, the function name must start with a dollar sign. Also, to receive the returned result as a reference, you must call <code>Pct.byRef</code>.
      </p>
      <div class="code">
        <pre><code class="pratphall">//assign
var a = 'hey';
var b = Pct.byRef(a);
//pass
function addWord($val: string) {
    $val += ' word';
}
addWord(b);
echo('Changed? ' + (a == 'hey word'));
//return
var c = { d: 15 };
function $getReference(val: { d: number; }) {
    return val.d;
}
var e = Pct.byRef($getReference(c));
e = 20;
echo('Changed? ' + (c.d == 20));</code></pre>
        <pre><code class="php">//assign
$a = 'hey';
$b = &amp;$a;
//pass
function addWord(&amp;$val) {
    $val .= ' word';
}
addWord($b);
echo('Changed? ' . ($a == 'hey word'));
//return
$c = (object)['d' => 15];
function &amp;getReference($val) {
    return $val->d;
}
$e = &amp;getReference($c);
$e = 20;
echo('Changed? ' . ($c->d == 20));</code></pre>
      </div>

      <span class="bookmark" id="Manual-Structure"></span>
      <h3>Structure</h3>

      <h4>Function Basics</h4>
      <p>
        Functions in Pratphall behave very similarly to PHP.
      </p>
      <p>
        Overloads declarations are allowed in Pratphall like they are in TypeScript, but only one "catch all" function with an implementation is allowed. The overloaded signatures will be discarded.
      </p>
      <p>
        Type hinting is done by default for arrays, callables, and actual type declarations. Parameters who are typed with compile time only types (see compile time declarations below) will not be type hinted. If the compiler option <code>--no-type-hint</code> is set, type hinting will not be present on any function.
      </p>

      <h4>Variadic Functions</h4>
      <p>
        Pratphall directly supports typed variadic function arguments (known as "RestParameters" in the TypeScript specification) whereas PHP does not. The use of variadic functions is not encouraged, but supported.
      </p>
      <p>
        When the <code>arguments</code> array is referenced in a function, it is translated to PHP by using <code>func_get_args</code> (see GOTCHA-023 about re-defining arguments). When a rest parameter is used as a parameter in a function, it is derived from <code>func_get_args</code>
      </p>
      <div class="code">
        <pre><code class="pratphall">function myprint(one: string, ...args: any[]) {
    /* left blank to make comparison easier */

    echo('First: ' + arguments[0] + '\n');
    echo('Last: ' + arguments[arguments.length - 1] + '\n');
    if (args.length > 0) {
        echo('First args: ' + args[0] + '\n');
        echo('Last args: ' + args[args.length - 1] + '\n');
    }
}

myprint('foo', true, 13.5, 'bar');</code></pre>
        <pre><code class="php">function myprint($one) {
    $arguments = func_get_args();
    $args = array_slice(func_get_args(), 1);
    echo('First: ' . $arguments[0] + "\n");
    echo('Last: ' . $arguments[count($arguments) - 1] . "\n");
    if (count($args) > 0) {
        echo('First args: ' . $args[0] . '\n');
        echo('Last args: ' . $args[count($args) - 1] . "\n");
    }
}

myprint('foo', true, 13.5, 'bar');</code></pre>
      </div>

      <h4>Optional Function Parameters</h4>
      <p>
        Both PHP and Pratphall support optional function parameters. PHP supports only default parameters with only scalars/arrays and they can be anywhere within the parameter list. Pratphall supports both optional and default parameters which can be initialized to any type and must be at the end of the parameter list.
      </p>
      <p>
        Optional parameters in Pratphall without a default value are assumed to be null. If the default parameter is specified and it is not a constant, scalar value, it will be set at the beginning of the function (this practice is usually discouraged).
      </p>
      <div class="code">
        <pre><code class="pratphall">function words(prefix?: bool, file = file('default.txt')) {
    /* left blank to make comparison easier */
    file.forEach((line: string) => {
        line.split(' ').forEach((word: string) => {
            if (prefix) echo('Word: ');
            echo(word + '\n');
        });
    });
}

//reads default.txt and prints w/out prefix
printWords();
//reads myfile.txt and prints w/ prefix
printWords(true, ['foo bar', 'fu bar']);</code></pre>
        <pre><code class="php">function words($prefix = false, $file = null) {
    if ($file === null) $file = file('default.txt');
    foreach ($file as $line) {
        foreach (explode(' ', $line) as $word) {
            if ($prefix) echo('Word: ');
            echo($word . "\n");
        }
    }
}

//reads default.txt and prints w/out prefix
printWords();
//uses array and prints w/ prefix
printWords(true, ['foo bar', 'fu bar']);</code></pre>
      </div>

      <h4>Anonymous and Nested Functions</h4>
      <p>
        Pratphall and PHP have support for anonymous functions with a common syntax and are invoked and passed the same way.
      </p>
      <p>
        PHP's parser supports nested functions, but it places them in the global scope. Pratphall does NOT support these nested functions. When Pratphall encounters a nested function, it treats it like an anonymous function assigned to the variable of the same name. This means the compiler will error if a variable and nested function appear in the same function with the same name.
      </p>
      <div class="code">
        <pre><code class="pratphall">function func() {
    var anonFunc = (value: string) => { echo(value); }
    var anonFunc2 = function (value: string) { echo(value); }
    function nestedFunc(value: string) { echo(value); }
}</code></pre>
        <pre><code class="php">function func() {
    $anonFunc = function ($value) { echo($value); };
    $anonFunc2 = function ($value) { echo($value); };
    $nestedFunc = function ($value) { echo($value); };
}</code></pre>
      </div>

      <h4>Try/Catch</h4>
      <p>
        Pratphall's (ahem, JS's) native try/catch syntax is much more limited than PHP's. It is supported and will even emit PHP 5.5 finally statements. You can compile-time cast the catch variable or do an instanceof check.
      </p>
      <div class="code">
        <pre><code class="pratphall">try {
    new ReflectionClass('NonExistentClass');
} catch (err) {
    if (err instanceof ReflectionException) {
        echo('Not found: ' + (&lt;Exception>err).getMessage());
    } else {
        echo('Other: ' + (&lt;Exception>err).getMessage());
    }
} finally {
    echo('This runs always in PHP 5.5');
}</code></pre>
        <pre><code class="php">try {
    new ReflectionClass('NonExistentClass');
} catch (Exception $err) {
    if ($err instanceof ReflectionException) {
        echo('Not found: ' . $err->getMessage());
    } else {
        echo('Other: ' . $err->getMessage());
    }
} finally {
    echo('This runs always in PHP 5.5');
}</code></pre>
      </div>
      <p>
        Pratphall does include compile-time helpers to support the full try/catch syntax via <code>Pct.try</code>. It is an object literal w/ a try function, an optional catch function (or array of functions), and an optional finally function. If neither a catch nor finally is supplied, it assumes an empty catch statement.
      </p>
      <div class="code">
        <pre><code class="pratphall">Pct.try({
    try: () => {
        new ReflectionClass('NonExistentClass');
    },
    catch: [
        (err: ReflectionException) => {
            echo('Not found: ' + err.getMessage());
        },
        (err: Exception) => {
            echo('Other: ' + err.getMessage());
        }
    ],
    finally: () => {
        echo('This runs always in PHP 5.5');
    }
});</code></pre>
        <pre><code class="php">try {
    new ReflectionClass('NonExistentClass');
} catch (ReflectionException $err) {
    echo('Not found: ' . $err.getMessage());
} catch (Exception $err) {
    echo('Other: ' . $err.getMessage());
} finally {
    echo('This runs always in PHP 5.5');
}</code></pre>
      </div>

      <h4>Classes and Interfaces</h4>
      <p>
        Pratphall supports classes and interfaces just like PHP. There are several features that Pratphall does not support:
        <ul>
          <li>
            <strong>abstract</strong> - No abstract members or classes are supported. There is no equivalent. (future possibility, see <a href="http://typescript.codeplex.com/workitem/395">TS-395</a> or maybe find some other way w/ function sigs in classes)
          </li>
          <li>
            <strong>class constants</strong> - The closest you can get is public static properties. To interoperate with existing constants, you may use <code>Pct.const</code>. Also, you may use the <code>--all-caps-consts</code> compiler option to assume all uppercase references AND definitions of public static properties are constants. (future possibility, see <a href="http://typescript.codeplex.com/workitem/368">TS-368</a>)
          </li>
          <li>
            <strong>protected</strong> - There simply is no equivalent. When making ambient declarations to interoperate with existing PHP code, choose private or public depending on whether you plan to inherit. (future possibility, see <a href="http://typescript.codeplex.com/workitem/125">TS-125</a>)
          </li>
          <li>
            <strong>traits</strong> - No equivalent. To interoperate with code that uses traits, just use interfaces. (future possibility if TypeScript supports mixins)
          </li>
          <li>
            <strong>property accessors</strong> - No equivalent. (future possibility, see <a href="https://wiki.php.net/rfc/propertygetsetsyntax-v1.2">PHP RFC</a>)
          </li>
          <li>
            <strong>final</strong> - No equivalent. (future possibility, see <a href="http://typescript.codeplex.com/workitem/352">TS-352</a>)
          </li>
          <li>
            <strong>self/static</strong> - Cannot use <code>self::</code> or <code>static::</code> to reference static members. Instead, you must use the class name explicitly. This means there is no late static binding. (future possibility, have a compile-time helper like <code>Pct.self</code> or <code>Pct.static</code>)
          </li>
        </ul>
        Despite these non-existent features, the Pratphall object-oriented system is very strong. Actually, in practice we've found the absence of some of these features leads to cleaner code. Here are some features that Pratphall does support:
        <ul>
          <li>
            <strong>constructors</strong> - Use <code>constructor</code> in Pratphall which translates to <code>__construct</code>. A member named <code>__construct</code> in Pratphall is an error. Also, using public or private before variable declarations in a constructor automatically make them properties.
          </li>
          <li>
            <strong>public by default</strong> - All members are public by default.
          </li>
          <li>
            <strong>interface properties</strong> - Interfaces can define properties that the class needs to end up defining. Note, these are NOT emitted to PHP, they are a compile-time only feature.
          </li>
          <li>
            <strong>super calls</strong> - To call a parent method inside an overload, use <code>super</code> which is translated to <code>parent</code> in PHP.
          </li>
          <li>
            <strong>overloads</strong> - Overloaded methods are supported in classes just like normal overloaded functions. This means there must be a single catch-all implementation and the overload signatures are not emitted.
          </li>
          <li>
            <strong>callable class</strong> - When calling the class or passing around the class as a callable closure, simply pass around a reference to <code>__invoke</code> and it will automatically be removed. Until bare call signature implementations are supported in classes, you cannot call the class as a function directly.
          </li>
          <li>
            <strong>toString</strong> - In Pratphall, <code>toString</code> becomes <code>__toString</code>. A member named <code>__toString</code> in Pratphall is an error.
          </li>
          <li>
            <strong>property initialization</strong> - In Pratphall a property (static or not) may be initialized in any way unlike PHP which requires a constant. If an instance property is initialized with a non-constant value, it is set in the constructor (if the constructor doesn't exist, it copies the base class constructor and defers to it). If a static property is initialized with a non-constant value, it is set just after the class declaration in PHP. Note, private static properties with non-constant initializers are set via reflection.
          </li>
          <li>
            <strong>optional members</strong> - In Pratphall, using a question mark after a function or property name in an interface means the implementer doesn't have to implement it. Optional members are NOT emitted to PHP, they are a compile-time only feature.
          </li>
          <li>
            <strong>magic methods</strong> - All magic methods besides <code>__construct</code> and <code>__toString</code> are supported as normal methods. If they are not public, an error occurs. Be advised, the compile-time type system is unaware of runtime-derived members from things like <code>__get</code>, <code>__callStatic</code>, etc. Pratphall discourages the use of these magic methods, but if you must, cast to any first then cast the result back.
          </li>
        </ul>
      </p>
      <div class="code">
        <pre><code class="pratphall">//spacing added below for clarity
interface Iface {

    numberProperty: number;

    print(param: string);

    notRequired?(...params: any[]): bool;
}

class BaseClass {

    static fileContents = file_get_contents('myfile.txt');



    constructor(public numberProperty: number) {

        echo('Constructed!')
    }
}


class MyClass extends BaseClass implements Iface {

    static getFileContents() {
        return BaseClass.fileContents;
    }

    constructor() {
        super(12);
    }

    __destruct() { echo('Destructing!\n'); }

    private secretFunction() { echo('Hello\n'); }

    print(param: string) {
        echo('Value: ' + param + '\n');
    }

    __invoke(someVal: any) {
        echo('I have been invoked!\n');
        return this.numberProperty + Pct.castInt(someVal);
    }

    __get(prop: string) { return 42; }

    __set(prop: string, value: any) {
        echo('Setting ' + prop + ' with ' + value);
    }

    toString() { return 'MyClass'; }
}

var myClass = new MyClass();
echo('Instance? ' + (myClass instanceof Iface) + '\n');
//call static
var a = MyClass.getFileContents();
//call normal
myClass.print('Hey');
//invoke
var b = myClass.__invoke(20);
var c = myClass.__invoke('15');
//trigger getter/setter
var d = &lt;number&gt;(&lt;any&gt;myClass).someProp;
(&lt;any&gt;myClass).someNewProp = 20;
//string version
var e = myClass.toString();</code></pre>
        <pre><code class="php">//spacing added below for clarity
interface Iface {



    public function print($param);


}

class BaseClass {

    public static $fileContents;

    public $numberProperty;

    public function __construct($numberProperty) {
        $this->numberProperty = $numberProperty;
        echo('Constructed!');
    }
}
BaseClass::$fileContents = file_get_contents('myfile.txt');

class MyClass extends BaseClass implements Iface {

    public static function getFileContents() {
        return BaseClass::$fileContents;
    }

    public function __construct() {
        parent::__construct(12);
    }

    public function __destruct() { echo("Destructing!\n"); }

    private function secretFunction() { echo("Hello\n"); }

    public function print($param) {
        echo('Value: ' . $param . "\n");
    }

    public function __invoke($someVal) {
        echo("I have been invoked!\n");
        return $this->numberProperty + (int) $someVal;
    }

    public function __get($prop) { return 42; }

    public function __set($prop, $value) {
        echo('Setting ' . $prop . ' with ' . $value);
    }

    public function __toString() { return 'MyClass'; }
}

$myClass = new MyClass();
echo('Instance? ' . ($myClass instanceof Iface) . "\n");
//call static
$a = MyClass::getFileContents();
//call normal
$myClass->print('Hey');
//invoke
$b = $myClass(20);
$c = $myClass('15');
//trigger getter/setter
$d = $myClass->someProp;
$myClass->someNewProp = 20;
//string version
$e = strval($myClass);</code></pre>
      </div>

      <h4>Ambient and Compile-Time Declarations</h4>
      <p>
        Ambient class, interface, variable, and function declarations are not emitted with the PHP output. They are best suited for describing external code. To make a variable, class, or function ambient, simple use the <code>declare</code> keyword before it. To make an interface ambient, make the interface explicitly extend <code>Pct.Ambient</code>. Another way to make all of these ambient is to simply place them in a declaration file (which is a file that has the <code>.d.ts</code> extension). For example, here is the contents of <code>json.d.ts</code> which describes the <a href="http://php.net/manual/en/book.json.php">JSON</a> library:
      </p>
      <pre><code class="pratphall">var JSON_ERROR_CTRL_CHAR: number;
var JSON_ERROR_DEPTH: number;
var JSON_ERROR_NONE: number;
var JSON_ERROR_STATE_MISMATCH: number;
var JSON_ERROR_SYNTAX: number;
var JSON_ERROR_UTF8: number;

var JSON_BIGINT_AS_STRING: number;
var JSON_FORCE_OBJECT: number;
var JSON_HEX_AMP: number;
var JSON_HEX_APOS: number;
var JSON_HEX_QUOT: number;
var JSON_HEX_TAG: number;
var JSON_NUMERIC_CHECK: number;
var JSON_PRETTY_PRINT: number;
var JSON_UNESCAPED_SLASHES: number;
var JSON_UNESCAPED_UNICODE: number;

interface JsonSerializable {
    jsonSerialize(): any;
}

function json_decode(json: string, assoc?: bool, depth?: number, options?: number): any;
function json_encode(value: any, options?: number): string;
function json_last_error(): number;</code></pre>
      <p>
        Since ambient types are still seen at runtime, they will be emitted as type hints. Compile-time declarations do not suffer from this. They are only there to enforce a certain contract and that's it. Only interfaces and classes can be marked compile-time only, and this is done by extending or implementing the <code>Pct.CompileTimeOnly</code> interface.
      </p>
      <div class="code">
        <pre><code class="pratphall">interface Location extends Pct.CompileTimeOnly {
    zip: string;
    city?: string;
}

interface Weather extends Pct.CompileTimeOnly {
    location: Location;
    temperature: number;
}

function printWeather(value: Weather) {
    echo('It is ' + weather.temperature + ' in ');
    if (property_exists(value, 'city') echo(value.city);
    else echo(value.zip);
}

printWeather({
    location: {
        zip: '75001',
        city: 'Addison'
    },
    temperature: 85
});
printWeather({
    location: {zip: '76020'},
    temperature: 88
});</code></pre>
        <pre><code class="php">









function printWeather($value) {
    echo('It is' . $value->temperature . ' in ');
    if (property_exists($value, 'city') echo($value->city);
    else echo($value->zip);
}

printWeather((object)[
    'location' => (object)[
        'zip' => '75001',
        'city' => 'Addison'
    ],
    'temperature' => 85
]);
printWeather((object)[
    'location' => (object)['zip' => '76020'],
    'temperature' => 88
]);</code></pre>
      </div>


      <h4>Modules and References</h4>
      <p>
        Modules in Pratphall are directly translatable as namespaces in PHP.
      </p>
      <p>
        Even though PHP namespaces cannot be nested, Pratphall modules can. When emitted to PHP, they are separated. The dots translate to slashes in PHP. When not in the global namespace, globally namespaced type references are automatically prefixed with a slash.
      </p>
      <p>
        If a module is imported with an alias, it is translated to a use statement. If the alias is the same as the last module part, the <code>as</code> alias in the use statement is not emitted. Currently, Pratphall can only import and alias other modules, there is no importing or aliasing of other classes/interfaces. The <code>namespace</code> operator to access something in the same module is not present in Pratphall.
      </p>
      <p>
        External module references that use <code>import mod = module('modname')</code> format cause a compiler warning and are ignored for now. Use of the export feature to share items amongst modules is strictly a compile-time feature and is not emitted to PHP.
      </p>
      <p>
        If you must reference code in another file, you can use <code>///&lt;reference path="PATH" /&gt;</code>. It is common practice to reference a file that might just be full of references to the other files in the project. This is just a compile-time reference unless both <code>--no-organize</code> and <code>--require-references</code> are set as compiler options. note, unless <code>--no-composer</code> is present, the Composer autoloader will be loaded at the top.
      </p>
      <p>
        Different compiler options affect how the files are outputted. Below are descriptions of the options and output PHP examples based on these two files:
        <pre><code class="pratphall">//file1.ts
module MyModule {
    interface MyIface {
    }

    module Sub {
        class MyClass implements MyModule.MyIface {
            causeErr() {
                throw new Exception('Error');
            }
        }
    }
}

//file2.ts
///&lt;reference path="file1.ts" />
import Sub = MyModule.Sub;
var a = new Sub.MyClass();
a.causeErr();</code></pre>
        <dl>
          <dt>default</dt>
          <dd>
            By default, all classes and interfaces are written into their own file according to <a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md">PSR-0</a>. This means that except for the initial file passed to the compiler, no other files may have any top-level vars/functions or be in the global namespace. Also, unless <code>--no-composer</code> is present, the Composer autoloader will be loaded at the top.
            <pre><code class="php">//MyModule/MyIface.php
namespace MyModule;

interface MyIface {
}

//MyModule/Sub/MyClass.php
namespace MyModule\Sub;

class MyClass implements MyModule\MyIface
    public function causeErr() {
        throw new \Exception('Error');
    }
}

//file2.php
require('vendor/autoload.php');
use MyModule\Sub;
$a = new Sub\MyClass();
$a->causeErr();</code></pre>
          </dd>
          <dt>with <code>--no-organize</code></dt>
          <dd>
            When this option is set, all emitted PHP files are the same name as the Pratphall source files (.ts files) but with PHP extensions. This cannot be used with <code>--single</code> since that option basically includes this option. This option allows top-level code in any file and allows any file to operate in the global namespace. This option is best used in conjunction with <code>--require-references</code>. When that option is set, the <code>///&lt;reference path="PATH" /&gt;</code> references become <code>require_once</code> calls in PHP.
            <pre><code class="php">//file1.php
namespace MyModule {

    interface MyIface {
    }

}

namespace MyModule\Sub {

    class MyClass implements MyModule\MyIface
        public function causeErr() {
            throw new \Exception('Error');
        }
    }

}

//file2.php
require('vendor/autoload.php');
use MyModule\Sub;
$a = new Sub\MyClass();
$a->causeErr();</code></pre>
          </dd>
          <dt>with <code>--single</code></dt>
          <dd>
            When this option is set, all Pratphall code is emitted to a single PHP file. Like the default, this means that except for the initial file passed to the compiler, no other files may have any top-level vars/functions. However, any file can have contents in the global namespace. This cannot be used with <code>--no-organize</code>.
            <pre><code class="php">//file2.php
require('vendor/autoload.php');
namespace MyModule {

    interface MyIface {
    }

}

namespace MyModule\Sub {

    class MyClass implements MyModule\MyIface
        public function causeErr() {
            throw new \Exception('Error');
        }
    }

}

namespace {
    use MyModule\Sub;
    $a = new Sub\MyClass();
    $a->causeErr();
}</code></pre>
          </dd>
        </dl>
      </p>

      <span class="bookmark" id="Manual-Metaprogramming"></span>
      <h3>Metaprogramming</h3>

      <h4>Emitter Extensions</h3>
      <p></p>

      <h4>Validators</h3>
      <p></p>

      <!-- TODO: more work -->

      <span class="bookmark" id="Manual-Faq"></span>
      <h3>FAQ</h3>

      <dl>
        <dt>This is neat, so I can convert my PHP programs to JavaScript/TypeScript? Can I convert my JavaScript/TypeScript programs to PHP?</dt>
        <dd>
          No and no (basically). The goal of this project is to provide a new language that emits PHP. Pratphall intentionally doesn't convert existing code because it would put too many constraints on the language's freedom and would require a significant runtime layer which is unacceptable.
        </dd>
        <dt>Well, can you generate the ambient declarations from existing PHP code with strong PHPDoc blocks? Or maybe generate PHPDoc annotations when emitting?</dt>
        <dd>
          In theory, ambient declarations could be generated from existing PHP code. Also, PHPDoc annotations could be generated during compilation. The problem is that PHPDoc and Pratphall's typing systems don't lineup very well. For example, PHPDoc doesn't support differentiating between numerically indexed arrays and associative arrays. And Pratphall doesn't support knowing whether a value is nullable or not (e.g. the <code>string|null</code> PHPDoc type).
        </dd>
        <dt>Ok, then can I at least write Pratphall code that can also run in a JavaScript environment?</dt>
        <dd>
          Technically, yes. Many features of JavaScript/TypeScript are supported. If you are careful and abstract properly, some of your Pratphall code can also run in a browser. For instance, imagine you had a bunch of model objects that are serialized to and from JSON for use in RESTful API calls. If you needed the server side to have these models for processing and the client side to have them for an AJAX call, you could share the Pratphall model code.
        </dd>
        <dt>How does this effort relate to <a href="http://phpjs.org">php.js</a>? Can I use it?</dt>
        <dd>
          Pratphall has not been tested with php.js in any way whatsoever, so use at your own risk. Though, in theory there are two ways Pratphall and php.js can work together. Firstly, if you were targeting both a JS environment and PHP, php.js has runtime support for many of the PHP functions you may need in both environments. Secondly, Pratphall supplies typed definitions for all PHP functions which means even if you're not developing in Pratphall and instead just developing in TypeScript, you now have a typed set of definitions for all the phpjs functions.
        </dd>
        <dt>You are almost there for supporting the entire language of JavaScript/TypeScript, why not support it 100%? Then you can bootstrap Pratphall in PHP too.</dt>
        <dd>
          This would require too much runtime support since certain features of JavaScript/TypeScript have no equivalent in PHP. It is possible that an ancillary fork of Pratphall may aim to support the entirety of JavaScript/TypeScript, but it will be as an extension because Pratphall's goal is to compile to readable, minimal, and predictable PHP.
        </dd>
        <dt>What is the minimum PHP version Pratphall supports?</dt>
        <dd>
          Currently, it is PHP 5.4. Several features (mainly short array syntax and closures w/ $this) are required. If you use <code>finally</code> in your try blocks, then PHP 5.5 is required. This decision was made since Pratphall is a new language and should not be bound by older environments. It is possible that 5.3 will be supported with a compiler option if there is enough need.
        </dd>
        <dt>I have heard that "transpiled" languages suffer from debugging issues. How do you debug code in Pratphall?</dt>
        <dd>
          Currently there is no easy method to debug Pratphall in your favorite editor. If the Visual Studio protocol was more public and friendly (i.e. not COM/DCOM) we could write a proxy to convert Xdebug events to Visual Studio events (if anyone can help here, we'd appreciate it). If node-inspector accepted source mapping (ref <a href="https://github.com/dannycoates/node-inspector/issues/100">issue 100</a>) we could possibly proxy the Xdebug events to V8 protocol. Or if <a href="http://jbaron.github.com/cats/">CATS</a> had integrated debugging w/ V8 protocol, we could do it there too (ref <a href="https://github.com/jbaron/cats/issues/6">issue 6</a>). Maybe the best idea is to combine the source map support in Chrome Canary and the remote debugger protocol and use Chrome's devtools as the client (maybe embedded via node-webkit). But for now, there is no direct debugging.
        </dd>
        <dt>How complete is this? Should I depend on it for production code?</dt>
        <dd>
          It is fairly complete, however TypeScript itself is still only in preview. They might implement new features or change existing ones which can affect Pratphall. Using for production code shouldn't be a problem since the language is cross-compiled and the PHP is easily readable and auditable. The only real problem comes from backwards incompatibilities from Pratphall being unstable. Pratphall's first stable release will not be before TypeScript's first stable release (and maybe well after, depending).
        </dd>
      </dl>

      <span class="bookmark" id="Manual-Appendices"></span>
      <h3>Appendices</h3>

      <h4>Visual Studio Support</h4>
      <p>...</p>

      <h4>Building From Source</h4>
      <p>...</p>

      <h4>Gotchas</h4>
      <p>
        Below are gotchas that might not be expected during development
      </p>
      <dl>
        <dt><code>004: String.charCodeAt only uses ord when emitting</code></dt>
        <dd>
          Even though <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/charCodeAt">String.charCodeAt</a> supports unicode in JS, we only use <a href="http://php.net/manual/en/function.ord.php">ord</a>. Please handle unicode needs separately.
        </dd>
        <dt><code>005: String.indexOf emits more than just strpos</code></dt>
        <dd>Due to the fact the JS one returns -1, the emitter emulates that</dd>
        <dt><code>006: Regular expressions are flat out unsupported</code></dt>
        <dd>JS and PHP's regular expression syntaxes differ too much to support right now</dd>
        <dt><code>007: String.replace doesn't support callback</code></dt>
        <dd>There is no str_replace_callback in PHP, only a regex version</dd>
        <dt><code>008: String.slice and String.substring are unsupported</code></dt>
        <dd>
          Although negatives work the same for end and length in slice and substr, there is not an easy way to determine negative. Same issue with converting from end to length. It would require too much runtime support on the PHP side.
        </dd>
        <dt><code>009: String.toLocaleLowerCase and toLocaleUpperCase are unsupported</code></dt>
        <dd>There is no guarantee that mb_ functions are available</dd>
        <dt><code>010: Object.valueOfis unsupported</code></dt>
        <dd>No equivalent in PHP</dd>
        <dt><code>011: Many Object functions (e.g. freeze) are unsupported</code></dt>
        <dd>No equivalents in PHP, but no errors emitted because they can be overridden</dd>
        <dt><code>012: Array.reverse is unsupported</code></dt>
        <dd>No equivalent in PHP that alters the array instance</dd>
        <dt><code>013: Array iteration functions don't really support second parameter "this"</code></dt>
        <dd>
          The only value allowed as a second parameter in an array iteration function is literal "this".
        </dd>
        <dt><code>014: Array.every is unsupported</code></dt>
        <dd>No PHP equivalent</dd>
        <dt><code>015: Array.indexOf is unsupported</code></dt>
        <dd>
          array_search can't support fromIndex, would have to be strict, and would require too much runtime support to make false return -1.
        </dd>
        <dt><code>016: Array.join assumes comma by default</code></dt>
        <dd>
          A comma is used as the glue for implode if not specified.
        </dd>
        <dt><code>017: Array.lastIndexOf is unsupported</code></dt>
        <dd>No PHP equivalent</dd>
        <dt><code>018: Array.reduceRight is unsupported</code></dt>
        <dd>No PHP equivalent</dd>
        <dt><code>019: Second parameter of Array.slice is unsupported</code></dt>
        <dd>No PHP equivalent</dd>
        <dt><code>020: Array.some is unsupported</code></dt>
        <dd>No PHP equivalent</dd>
        <dt><code>021: Second parameter of JSON.parse is unsupported</code></dt>
        <dd>No PHP equivalent</dd>
        <dt><code>022: Second and third parameters of JSON.stringify are unsupported</code></dt>
        <dd>No PHP equivalent</dd>
        <dt><code>023: the JS arguments variable that gets the function arguments is unavailable if redefined later in function</code></dt>
        <dd>
          Basically, if you use the arguments array, then create a var later named arguments, we cannot tell the one used above the re-declaration needs func_get_args. Basic rule of thumb is not to use the arguments array in a function unless you have to, and then don't redefine it in the function.
        </dd>
      </dl>

      <h4>Future</h4>
      <p>
        These are some items that could be implemented in the future.
        <ul>
          <li>
            Emit exact PHPDoc based on the <a href="https://github.com/phpDocumentor/phpDocumentor2/blob/master/docs/PSR.md">PSR</a>.
          </li>
          <li>
            Create a proxy to proxy Xdebug protocol to other debugging protocols used in common IDE's.
          </li>
        </ul>
      </p>

      <h4>Changelog</h4>
      <p>...</p>


    </div>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script src="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/js/bootstrap.min.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/7.3/highlight.min.js "></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-37431760-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

    </script>
  </body>
</html>